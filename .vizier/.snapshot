Running Snapshot — updated

Narrative theme
- Reduce operator friction: conversational intent is authorization to evolve the project. The assistant maintains a living snapshot and task list by default; users can explicitly opt out per turn.
- Editorial housekeeping: Canonicalize duplicated TODO artifacts so each thread has a single authoritative TODO with cross-links; add TODO garbage-collection during save to keep the garden clean.
- Codex-integrated posture: Codex now handles the heavy agent work directly, so Vizier trims internal orchestration threads and focuses on snapshot accuracy plus CLI guardrails.
- Pluggable agent posture: Vizier must treat “agent” as a swappable backend (Codex today, Claude and others next) with a stable interface for capabilities, prompts, and telemetry, so plan/approve/review flows don’t have to be rewritten each time a new CLI agent is introduced.
- Config-first posture: Treat configuration as a first-class surface above Git and external agents; new features should ship with repo/CLI knobs and sensible defaults so operators are not forced into an overly opinionated workflow but still get high utility out of the box.
- Lean backlog: Threads that do not protect Codex-era workflows were culled; the remaining arcs prioritize IO contracts, auditability, and documentation gates.
- Bureaucratic enforcement: Treat Vizier as the compliance enforcer for large-organization processes (architecture docs per change, auditable histories, PR-ready artifacts).
- Story-editor discipline: Convert conversations into focused snapshot/TODO deltas by default; each TODO advances a named thread at product-level granularity, cross-linking back to the Snapshot, and avoids bare “investigate X” items or duplicate threads. The base system prompt in `vizier-core/src/lib.rs::SYSTEM_PROMPT_BASE` now encodes this policy so Codex-backed agents inherit the same discipline.
- Commit-style epilogues: Assistant-facing responses collapse to a single, commit-message-like Outcome line that reports what changed, while detailed snapshot/TODO deltas and outcome JSON stay machine-oriented and live in .vizier rather than being printed verbatim.

Active threads
- Stdout/stderr contract + verbosity: ACTIVE (partially shipped). CLI now supports -q/-v/-vv, --no-ansi, and progress gating (Auto/Never/Always) wired through vizier-core::display with TTY checks. Spinner/progress rendering is suppressed in non‑TTY and when quiet; Codex JSON events now render as `[codex] phase — message` history lines that respect quiet/verbosity, so every ask/save/approve flow leaves a readable trace. Remaining work is to standardize a stable stdout Outcome line/JSON (outcome.v1) across commands. Stderr remains for progress/errors per verbosity; ensure no ANSI in non‑TTY. [Cross: Outcome summaries; see: .vizier/todo_stdout_stderr_contract_and_verbosity]
- Mode split: Human-first CLI vs Protocol Mode v1: ACTIVE. Default CLI output stays human-first with readable epilogues; Protocol mode is machine-first with structured JSON/NDJSON on stdout, no ANSI, deterministic ordering, and categorized exit codes. Planned toggle `--mode protocol` (not yet implemented); JSON stream will share the same event contract as the human-mode CLI output. [Cross: Stdout/stderr, Outcome summaries]
- Commit isolation + gates: ACTIVE. Conversation- and agent-sourced changes are staged behind a Pending Commit gate; assistant flows must funnel through the Auditor before commits land. [Depends on: Outcome summaries, Session logging]
- Default-Action Posture (DAP): ACTIVE. By default, snapshot and TODOs update on any directive unless the user opts out per-turn (e.g., prefixing “no-op:” or “discuss-only:”). CLI surfaces a one-line Outcome whenever DAP acts. [Cross: Outcome summaries]
- Outcome summaries: ACTIVE. A unified human epilogue and outcome.v1 JSON must reflect Auditor A/M/D/R facts and gate state after every action. [Depends on: Auditor]
- Architecture doc gate + compliance: ACTIVE. Every code change needs an attached architecture doc logged in commit history; Vizier enforces creation, storage, and linkage before merges or saves. [Depends on: Outcome summaries, Commit isolation/gates]
- Session logging to filesystem: ACTIVE (MVP shipped). CLI now writes repo-local `.vizier/sessions/<id>/session.json` artifacts (transcripts, repo state, config snapshot, outcome) and surfaces the path in outcomes/commits; each outcome now carries a `token_usage` totals+delta block so auditors can reconcile the CLI epilogue. Next steps are richer resume UX, redaction levers, and gate-aware checkpoints. [Depends on: Auditor facts, Outcome]
- TODO Garbage-Collection on save: ACTIVE. Vizier aggressively removes duplicate, superseded, empty, and orphaned TODOs during `vizier save` and after material TODO merges, with safety levers and clear Outcome reporting. [Depends on: Config, Auditor, VCS, file tracking, Snapshot Threads]
- Agent workflow orchestration: ACTIVE. Operators want Vizier to act as the conductor for multi-agent runs (snapshot wording sign-off → architecture doc draft → implementation → review/fix sign-off → `vizier save`), so the CLI/Auditor stack must expose those checkpoints and keep the VCS gates tight. `vizier review` now provides the dedicated critique/fix checkpoint with configurable check commands, review artifacts, and plan-status metadata, and the implementation-plan/review/merge prompts are now repo-configurable via the prompt store, but we still need the broader conductor story (architecture-doc gate, pending-commit orchestration, workflow UI) plus a tamer flag surface for the rest of the plan workflow, and a codified CI/CD gate whose checks must pass before an agent-backed command is treated as successful. The merge step now wires that gate via `[merge.cicd_gate]` plus per-run overrides (`--cicd-script`, `--auto-cicd-fix`, `--no-auto-cicd-fix`, `--cicd-retries`) so merges cannot complete until the repo-defined script exits 0 (with Codex remediation when enabled), but we still need gate metadata flowing into Outcome summaries/session logs and reusable gate profiles for ask/save/draft/approve/review. [Cross: Commit isolation, Architecture doc gate, Outcome summaries; see: .vizier/todo_draft_approve_merge_config_surface.md, .vizier/todo_agent_command_cicd_gate.md]
- Agent backend abstraction + pluggable CLI agents: ACTIVE. Vizier now exposes scoped `[agents.default]`/`[agents.<command>]` config tables plus CLI overrides so each command (`ask`, `save`, `draft`, `approve`, `review`, `merge`) resolves its own `AgentSettings` (backend, model, reasoning, Codex bounds/binary). Auditor/session logs record the resolved backend + scope, token-usage lines append `agent=` details, docs describe the schema, and tests cover `[agents.ask]` overrides plus CLI `--backend wire` rejection on approve. Next steps are to split the “wire” transport from an agent interface (with per-agent options, capability probes, and telemetry adapters), define an agent-configuration story that knows which settings each backend understands and where they apply (global vs command-specific), and route `vizier draft/approve/review` through that abstraction so Codex, Claude, or any compliant agent can be swapped in without rewriting the workflow. Prompt templates (base/commit plus implementation-plan/review/merge-conflict) already flow through the config store so backend swaps inherit repo-specific instructions, but the transport/capability abstraction is still missing. [Cross: Agent workflow orchestration, Codex backend path in Code state; see: .vizier/todo_pluggable_agent_backends.md]
- Configuration posture + defaults: ACTIVE. Configuration is treated as a first-class surface above Git and external agents; new features and threads should expose their levers through a coherent config story with repo/CLI knobs and sensible defaults, so operators get a high-utility but non-imposed experience while still satisfying governance and workflow constraints. [Cross: Agent workflow orchestration, Agent backend abstraction + pluggable CLI agents, Architecture doc gate + compliance, Stdout/stderr contract + verbosity; see: .vizier/todo_configuration_posture_and_defaults.md]

Code state (behaviors that matter)
- Display/verbosity: vizier-cli wires -q/-v/-vv and --no-ansi into vizier-core::display; progress rendering is gated by stdout/stderr TTY and verbosity. Non‑TTY no longer leaks ANSI spinner frames; Info/Debug lines are governed by verbosity.
- Codex progress history: Instead of an overwriting spinner, every Codex event now renders to stderr as `[codex] <phase> — <message>` with percentage, status, and any detail/path gleaned from the event payload (`phase`, `label`, `message`, `detail`, `data.path`, `progress`, `status`, `timestamp`). Quiet mode suppresses the stream, while `-v/-vv` add timestamps and the raw JSON for auditing. `vizier approve` and Codex-powered conflict auto-resolution now share the same renderer instead of streaming raw stdout.
- stdout usage remains inconsistent; some commands (e.g., save, snapshot init, clean) emit ad‑hoc outcome lines, but there is no standardized outcome.v1 JSON or unified Outcome component yet.
- No explicit mode switch exists; protocol-style behavior is not yet implemented. `--json` prints conversation JSON in some paths but is not the outcome.v1 schema. JSON stream/eventing for Codex is present internally.
- Interactive chat command removed; the former alt-screen UI and its supporting modules (`vizier-core/src/chat.rs`, `vizier-core/src/editor.rs`) were deleted, so all work happens through CLI commands (ask/draft/save/approve/review/merge) with no diff-preview surface.
- Commit confirmation detours were removed end-to-end: the `--require-confirmation` flag, chat/editor prompts, and run_editor TUI no longer exist, so commit messages come straight from the Auditor builder unless operators opt into `$EDITOR` via the existing `--commit-message-editor` flag.
- CommitMessageBuilder now lifts the first non-empty line of the Codex-generated commit summary into the commit subject for both code and narrative commits, so operators see the descriptive `feat:/chore:/docs:` headers they expect; if the summary is blank we still fall back to the legacy `VIZIER …` labels.
- `vizier-core` dropped the unused TUI crate dependency and the editor-specific tool glue (`tools::SENDER`, `edit_content`, `get_editor_tools`, `active_editor_tooling`), leaving only CLI-oriented tools exposed to the backend.
- README and CLI docs now describe a CLI-only workflow so operators aren’t pointed to a non-existent `vizier chat`.
- `vizier review` now exists as a first-class command: it reuses disposable worktrees, runs repo-defined checks (default Cargo check/test or `[review.checks] commands` overrides), streams Codex’s critique directly to stdout/session logs instead of writing `.vizier/reviews/<slug>.md`, bumps the plan document to `status: review-ready`, and optionally re-enters Codex to apply fixes on the draft branch (`--review-only` skips, `--skip-checks` omits the preflight commands, `-y/--yes` auto-applies). The CLI epilogue reports `critique=terminal` plus the session path, and commit author notes point back to the session log rather than a Markdown artifact.
- `vizier list`/`PlanSlugInventory` now surface plan status + `reviewed_at` so operators (and completions) see which draft branches already passed the review checkpoint; `vizier review` keeps that metadata fresh even when checks are skipped.
- README, docs/workflows/draft-approve-merge.md, and AGENTS.md have been updated to cover the extended draft→approve→review→merge choreography so multi-agent runs know where the critique/fix checkpoint lives.
- Assistant operations now route through the Auditor; diffs from assistant-initiated changes are reported with A/M/D/R. Each CLI run writes a structured session log to `.vizier/sessions/<session_id>/session.json` (timestamps, repo state, config snapshot, transcript, outcome) and references that path from commit bodies and Outcome lines; `--no-session` disables the writer when compliance requires it.
- CLI exposes global `--load-session <id>` and `--no-session` flags; `--load-session` reads repo-local `.vizier/sessions/<id>/session.json` artifacts (falling back to the old config-dir format when needed) so operators can resume from in-repo transcripts rather than `$XDG_CONFIG_HOME`.
- Post-action UX lacks a unified Outcome section; current ad-hoc lines (e.g., "Save complete; …", snapshot bootstrap summary) are not standardized. Auditor facts are available to drive a canonical epilogue. Outcome component remains a priority (CLI-first with outcome.v1 JSON and stdout epilogue). Canonical TODO added.
- No built-in agent command: Vizier intentionally lacks a `vizier agent run` flow; operators launch Codex directly and handle branch/PR plumbing outside the CLI.
- AGENTS.md contract/log: Describes the scoped `[agents.default]`/`[agents.<command>]` configuration (backend, fallback backend, model, reasoning, and Codex bounds/binary), spells out the precedence order (`CLI flags → [agents.<command>] → [agents.default] → legacy top-level keys`), and still serves as the short orientation note pointing agents to README, `.vizier/.snapshot`, prompts, and the draft→approve→merge workflow doc; it is not yet a full decision log.
- Repo-level configs are now first-class: when no `--config-file` is provided, Vizier probes `.vizier/config.toml` (falling back to `.vizier/config.json`) before consulting `~/.config/vizier/config.toml`, and `VIZIER_CONFIG_FILE` is now the lowest-precedence override. README, AGENTS.md, and `example-config.toml` document the order, logging reports which path was loaded, and unit/integration tests lock in the repo-vs-env precedence.
- TODO GC not yet implemented; policy and levers defined; to be wired into save path and Auditor Outcome.
- Docs prompt templates still ship under `.vizier/docs/prompting/`, but the standalone `vizier docs prompt` command was removed; the upcoming architecture-doc gate (see `.vizier/todo_architecture_doc_gate_and_commit_history.md`) will wire those templates back into the CLI.
- Legacy side commands (`vizier snapshot …`, `vizier docs prompt …`, and `vizier clean …`) were culled in favor of a lean surface: only `vizier init-snapshot` survives for bootstrap, and TODO hygiene now relies on Default-Action Posture plus the TODO GC work tracked in `.vizier/todo_todo_todo_garbage_collection_on_save.md`.
- Codex backend path now lives in `vizier-core/src/codex.rs`: the auditor spawns `codex exec --json --output-last-message` in the repo, streams progress events, captures token usage, falls back to the wire backend when Codex errors, and CODEX.md serves as the living rollout log for this flow. The runner now supports a passthrough output mode that drops `--json` and pipes Codex stdout/stderr straight to Vizier’s stderr while still harvesting the final assistant message via `--output-last-message`.
- Scoped agent settings now back every assistant command: `[agents.default]` and `[agents.ask|save|draft|approve|review|merge]` tables (plus CLI overrides) resolve to `AgentSettings` structs that carry backend, fallback, model, reasoning, and Codex bounds/binary per command. `vizier-cli` threads those settings through `run_save/ask/draft/approve/review/merge`, enforces capability checks (approve/review require Codex, merge auto-resolve refuses wire), updates Codex prompt builders with per-scope bounds, and surfaces the resolved backend+scope in session logs and the token-usage suffix (`agent=codex scope=approve`). Docs and integration tests cover the schema and precedence, including `[agents.ask]` overriding the default and CLI `--backend wire` being rejected for approve.
- Auditor commit plumbing now calls `FileTracker::sync_vizier_changes` before writing `.vizier` commits and returns early when nothing changed so Codex‑edited snapshot/TODO files get staged without disturbing pre‑existing staged code. Conversation commits were removed; session IDs + paths travel with the `.vizier` and code commits instead, while inline ask flows still commit `.vizier` changes immediately (Pending Commit gate still pending).
- Token usage reporting is now event-driven: each Codex/wire turn emits `[usage] token-usage — prompt=X (+Δ) completion=Y (+Δ) total=Z (+Δ) cached_input=C (+Δ) reasoning_output=R (+Δ)` progress lines that honor verbosity/TTY gating. CLI summaries now append `(tokens: total=T (+Δ) input=I (+Δ, +C cached) output=O (+Δ, reasoning R))`, and quiet mode suppresses the extra chatter; when the backend withholds usage data we fall back to a single `unknown` line with no deltas. Session logs mirror the same total/input/output breakdown so downstream tooling sees `Token usage: total=T (+Δ) input=I (+Δ, +C cached) output=O (+Δ, reasoning R)` with matching data in `.vizier/sessions/<id>/session.json`.
- Architecture doc compliance: no docs/architecture index exists and saves succeed without citing a doc, so there is no auditable linkage from code changes to architecture intent.
- `vizier draft` (Codex-only) provisions a `draft/<slug>` branch from the primary branch tip via a temporary worktree, runs Codex to generate `.vizier/implementation-plans/<slug>.md`, commits the plan on that branch, then cleans up the worktree so the operator’s checkout stays untouched while stdout reports the plan path/branch pairing.
- `vizier list` now exposes the pending-plan backlog as its own subcommand: it enumerates every `draft/<slug>` branch that sits ahead of the detected (or `--target`) branch, printing the existing `plan=… branch=… summary="…"` lines so operators/agents can inspect outstanding work without touching the approve flow; the legacy `vizier approve --list` flag is hidden/deprecated and emits a warning that points to the new command.
- `vizier approve` implements the approved plan on the draft branch in a disposable worktree (Codex-backed), auto-commits the branch so reviewers can diff against the target, and now streams Codex’s raw stdout/stderr directly to the CLI’s stderr via passthrough mode (Codex usage recorded as `unknown`). `vizier review` extends that workflow with a review checkpoint: it spins another worktree, runs the configured checks (defaults to `cargo check --all --all-targets` + `cargo test --all --all-targets` when `Cargo.toml` exists or the `[review.checks]` commands in config), captures the diff summary, streams Codex’s critique to stdout (session logs capture the transcript), marks the plan document `review-ready`, and optionally re-enters Codex to apply fixes using the in-memory critique (prompted unless `--review-only` or `-y/--yes`). `vizier merge` now removes `.vizier/implementation-plans/<slug>.md`, refreshes `.vizier` state, performs the non‑fast‑forward merge of `draft/<slug>` back onto the primary, and then enforces the optional CI/CD gate defined under `[merge.cicd_gate]` or `--cicd-script`. The gate runs from the repo root after the merge commit is staged; success prints the merge summary (deleting the draft branch unless `--keep-branch` is set), while failure streams the script’s stdout/stderr and aborts before deletion/push so operators can inspect the repo. CLI overrides (`--cicd-script PATH`, `--auto-cicd-fix`, `--no-auto-cicd-fix`, `--cicd-retries N`) merge with config, and Codex-backed merges can auto-remediate gate failures by applying scoped fixes (each fix attempt creates a `Fix CI/CD gate failure…` commit) before rerunning the script. Gate checks also run when resuming via `--complete-conflict`. Approve supports `-y/--yes`, `--target`, and `--branch`; Review adds `--review-only`, `--skip-checks`, `-y/--yes`, `--target`, and `--branch`; Merge now supports `-y/--yes`, `--keep-branch`, `--target`, `--branch`, `--note`, `--auto-resolve-conflicts`, `--complete-conflict`, `--cicd-script`, `--auto-cicd-fix`, `--no-auto-cicd-fix`, and `--cicd-retries`.
- Shell completions: `vizier completions <bash|zsh|fish|powershell|elvish>` prints a dynamic script that wires the hidden `vizier __complete` path to Clap’s completion engine; once sourced, Vizier offers subcommand/flag completion plus `vizier approve`/`vizier merge` positional tab-completion for pending plan slugs via the shared `PlanSlugInventory` helper (scans `.vizier/implementation-plans/*.md` plus `draft/*` branches, filters merged branches, and returns slug/branch/summary metadata for completions, `vizier list`, and docs). README + docs/workflows now call out the command so operators can install it alongside the draft→approve flow.
- Merge conflicts are now resumable: when libgit2 reports conflicts, Vizier materializes the merge index into the working tree, writes a resume token under `.vizier/tmp/merge-conflicts/<slug>.json`, and exits with guidance. Operators can resolve + rerun `vizier merge <slug> --complete-conflict` to reuse the stored commit metadata once the index is clean, or pass `--auto-resolve-conflicts` to let Codex attempt a scoped auto-resolution before falling back to manual cleanup. The completion flag refuses to run when no sentinel exists, when Git isn’t in merge state, or when the operator isn’t on the recorded target branch, keeping history tidy. Sentinel files are deleted automatically once the merge commits.
- Implementation-plan prompting now lives in `vizier-core/src/lib.rs::IMPLEMENTATION_PLAN_PROMPT`, and `vizier-core/src/codex.rs::build_implementation_plan_prompt` feeds Codex the snapshot, active threads, plan slug/branch metadata, and operator spec so the Markdown plan includes front-matter `{plan, branch, status:draft, created_at, spec_source}` plus “Operator Spec” and “Implementation Plan” sections.
- Implementation-plan, review, and merge-conflict prompts are now routed through the config prompt store: Vizier looks for `.vizier/IMPLEMENTATION_PLAN_PROMPT.md`, `.vizier/REVIEW_PROMPT.md`, and `.vizier/MERGE_CONFLICT_PROMPT.md` (or `[prompts.implementation_plan|review|merge_conflict]` overrides) before falling back to the baked constants, and the Codex builders always fetch the active template so repositories can retune plan/review/merge flows without recompiling; README plus `docs/workflows/draft-approve-merge.md` document the override story. Prompt resolution is now scoped per command: `[prompts.<scope>]` tables (ask/save/draft/approve/review/merge) override repo-level prompt files, which in turn outrank global `[prompts]` entries and the baked defaults. Every Codex/wire call now passes its `CommandScope` into the prompt builders so `vizier ask` can run with different guardrails than `vizier draft`, and fallback prompts honor the same precedence.
- Session logs now capture the active prompt scope/kind/origin, and Auditor exposes the repo-relative prompt path (when applicable) alongside the content hash so downstream tooling can tell whether a run used a scoped `[prompts.ask]` override, a `.vizier/*.md` file, or the defaults.
- New VCS helpers (`detect_primary_branch`, `create_branch_from`, `add_worktree_for_branch`, `commit_paths_in_repo`, merge helpers, etc.) manage temporary worktrees under `.vizier/tmp-worktrees/` (now gitignored) so `vizier draft` can stage/commit plan files without touching the operator checkout, and enable clean non‑FF merges for approvals.
- `tests/src/lib.rs` exposes standard `#[test]` cases built on an `IntegrationRepo` fixture that clones `test-repo` + `.vizier` into per-test temp dirs, configures Git identity, and caches the release `vizier` binary via `OnceLock`. Coverage spans `vizier save` flows, approve/merge wiring, conflict auto-resolution, sentinel creation, the `vizier review --review-only --skip-checks` scenario (now `test_review_streams_critique`, which asserts that no `.vizier/reviews` files exist and the critique header appears in stdout while the plan is marked `review-ready`), plus new CI/CD gate tests: `test_merge_cicd_gate_executes_script` (happy path), `test_merge_cicd_gate_failure_blocks_merge` (non-zero script exits block the merge and preserve the draft branch), and `test_merge_cicd_gate_auto_fix_applies_changes` (mock Codex remediation writes the expected fix file and commits the fix attempt).
- `vizier-core/src/vcs.rs` tests use a `TestRepo` fixture plus repo-aware helpers (`stage_in`, `add_and_commit_in`, `push_current_branch_in`, `unstage_in`) instead of mutating the process CWD, so `cargo test -p vizier-core` runs at default parallelism without `--test-threads=1`.
- README.md documents `vizier draft`, `vizier list` (standalone pending-plan backlog), `vizier approve` (implementation on the draft branch), and `vizier merge` (non‑FF merge that inlines the stored plan under `Implementation Plan:`) with accurate flags; copy updated to describe the CI/CD gate (`[merge.cicd_gate]`, `--cicd-script`, `--auto-cicd-fix`, `--no-auto-cicd-fix`, `--cicd-retries`). Dedicated DRAFT.md/APPROVE.md are still absent. [Cross: todo_README_add_approve_command.md]
- docs/workflows/draft-approve-merge.md now walks operators through the `vizier draft → vizier approve → vizier merge` choreography, explicitly calling out `vizier list` as the way to inspect outstanding plan branches, and covers prerequisites, Git effects, conflict sentinels, walkthrough, FAQ, compliance tie-ins, plus the new CI/CD gate (config, CLI overrides, auto-remediation, failure recovery table).
- Global `--no-commit` flag (+ `[workflow] no_commit_default`) lets operators hold `.vizier` and plan-branch edits for manual review across ask/save/draft/approve/review. When active, Vizier skips the auto-commit/push, logs that changes are pending, and preserves the disposable worktree for inspection; `vizier merge` still requires auto-commit because merge commits and CI/CD gates depend on finalized history. README and docs call out the new workflow along with the config lever.
- Multi-agent workflows are ad-hoc: there is no structured runbook that walks operators through “discuss → snapshot sign-off → architecture doc draft → implement → code sign-off → save,” so intent can drift between agents and VCS gates.

Acceptance checkpoints (selected)
- Stdout/stderr contract: Non‑TTY emits no ANSI; stdout carries final results; stderr stays limited to errors/warnings per verbosity. Flags -q/-v/-vv and --no-ansi implemented; progress gated by TTY. outcome.v1 JSON not yet implemented; standardize across commands. [Active]
- Mode split: `--mode protocol` produces only structured JSON/NDJSON on stdout (no human prose), no ANSI in any environment, deterministic event ordering, and categorized exit codes. Chat mode remains default with human epilogue and optional `--json`/`--json-stream`. Closed-stdin never blocks. [Active]
- Pending Commit gate guards conversation changes with confirm_destructive=true and auto_commit=false.
- Conversation commits only touch .vizier; preserve pre-existing staged changes exactly (A/M/D/R).
- Non-interactive CLI requires explicit consent; never opens editor.
- Session JSON logging: Assistant operations persist structured session records under repo-local `.vizier/sessions/<id>/session.json` (transcript, repo state, config snapshot, prompt hash, model info, outcome summary); CLI epilogues and commits surface the session path, with schema validation, richer resume UX, gate-aware checkpoints, and redaction controls treated as follow-up work. [Active]
- Outcome summaries: After each operation, users see a compact summary matching Auditor/VCS facts; assistant final mirrors it. For CLI actions, the Auditor-backed A/M/D/R must be reflected in both human epilogue and outcome.v1 JSON. Deterministic final Outcome emission. [CLI-first]
- TODO GC on save: During `vizier save`, duplicate/superseded/empty/orphaned TODOs are deleted or staged for deletion per config; Outcome reports deletions with reasons; dry-run supported; protected items skipped. [Active]
- Architecture doc gate: Saves refuse to finalize without a cited architecture doc; outcomes and commits include the referenced path, and multi-agent runs share the same doc reference. [Planned]

Next moves
1) Stdout/stderr contract + verbosity: complete the contract by standardizing a stable stdout Outcome across commands and wiring an outcome.v1 JSON; keep spinner/ANSI gating as shipped. [Active]
2) Outcome component: implement outcome.v1 schema; include audited A/M/D/R, gate state, and (when applicable) {todo, branch, commit_count, pr_url}. Print to stdout on success; `--json`/stream variants. Ensure it fires after every ask/save. [Active]
3) Mode split wiring: Add `--mode protocol` to CLI, thread through to core display/observer; enforce protocol-mode IO rules, exit codes, and metadata {mode:"protocol"}. Ensure closed-stdin safe behavior. [Active]
4) Ask gate parity: Place assistant-initiated edits (ask flows) behind a Pending Commit gate instead of immediate commit; surface via Outcome/JSON. Preserve pre-existing staged work. [Active]
5) TODO GC wiring: Add product‑level GC behavior into save path with config/flags; surface detailed Outcome facts and integrate with Pending Commit gate where enabled. [Active]
6) Session logging follow-ups: now that repo-local `.vizier/sessions/<id>/session.json` artifacts ship with each run, add resume/diff tooling, redaction levers, and schema validation so downstream agents can trust the record. [Active]
7) Architecture doc enforcement + history: Add compliance gates that require architecture docs for every code change, store doc references alongside commits, and surface discrepancies via Auditor/Outcome before merge. [New]
8) Agent workflow orchestration: Give operators a first-class workflow that sequences snapshot approval, architecture doc drafting, implementation, code sign-off, and final `vizier save`, with Auditor/Outcome breadcrumbs for each checkpoint. [New]
9) Draft approval plumbing: SHIPPED. `vizier approve` applies the plan on the draft branch; `vizier merge` merges that branch back onto the primary with a non‑FF commit whose subject is `feat: merge plan <slug>` and whose body embeds the stored plan under `Implementation Plan:` plus any operator note. Follow‑ups: standardize Outcome epilogue/JSON for approve/list/merge, add protocol‑mode parity, surface session paths. [Active]

Cross-links
- Output contract + Mode split ↔ Outcome summaries: the same event stream feeds human epilogues, protocol JSON, and CLI results without ANSI leakage.
- DAP ↔ Outcome ↔ TODO GC: default-action edits update .vizier, GC keeps the garden tidy, and the Outcome line reports those edits.
- Commit isolation + gates ↔ Architecture doc compliance: pending commits and save gates must cite the architecture doc reference and surface it in outcomes/commits.
- Session logging ↔ Auditor facts: assistant operations persist audited facts to session.json, and the Outcome epilogue points to the artifact for downstream tooling.
- Agent workflows ↔ Commit/Doc gates: the same checkpoints that gate architecture docs and pending commits must be surfaced as workflow steps so multi-agent runs stay aligned and auditable.

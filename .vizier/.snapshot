Running Snapshot — updated

Narrative theme
- Reduce operator friction: conversational intent is authorization to evolve the project. The assistant maintains a living snapshot and task list by default; users can explicitly opt out per turn.
- Editorial housekeeping: Canonicalize duplicated TODO artifacts so each thread has a single authoritative TODO with cross-links; add TODO garbage-collection during save to keep the garden clean.
- Codex-integrated posture: Codex now handles the heavy agent work directly, so Vizier trims internal orchestration threads and focuses on snapshot accuracy plus CLI guardrails.
- Lean backlog: Threads that do not protect Codex-era workflows were culled; the remaining arcs prioritize IO contracts, auditability, and documentation gates.
- Bureaucratic enforcement: Treat Vizier as the compliance enforcer for large-organization processes (architecture docs per change, auditable histories, PR-ready artifacts).
 - Commit-style epilogues: Assistant-facing responses collapse to a single, commit-message-like Outcome line that reports what changed, while detailed snapshot/TODO deltas and outcome JSON stay machine-oriented and live in .vizier rather than being printed verbatim.

Active threads
- Stdout/stderr contract + verbosity: ACTIVE (partially shipped). CLI now supports -q/-v/-vv, --no-ansi, and progress gating (Auto/Never/Always) wired through vizier-core::display with TTY checks. Spinner/progress rendering is suppressed in non‑TTY and when quiet; remaining work is to standardize a stable stdout Outcome line/JSON (outcome.v1) across commands. Stderr remains for progress/errors per verbosity; ensure no ANSI in non‑TTY. [Cross: Outcome summaries]
- Mode split: Chat (default) vs Protocol Mode v1: ACTIVE. Chat remains human-first with readable epilogues; Protocol mode is machine-first with structured JSON/NDJSON on stdout, no ANSI, deterministic ordering, and categorized exit codes. Planned toggle `--mode protocol` (not yet implemented); JSON stream will share the same event contract as chat. [Cross: Stdout/stderr, Outcome summaries]
- Commit isolation + gates: ACTIVE. Conversation- and agent-sourced changes are staged behind a Pending Commit gate; chat flows must funnel through the Auditor before commits land. [Depends on: Outcome summaries, Session logging]
- Default-Action Posture (DAP): ACTIVE. By default, snapshot and TODOs update on any directive unless the user opts out (e.g., “discuss-only”). CLI surfaces a one-line Outcome whenever DAP acts. [Cross: Outcome summaries]
- Outcome summaries: ACTIVE. A unified human epilogue and outcome.v1 JSON must reflect Auditor A/M/D/R facts and gate state after every action. [Depends on: Auditor]
- Architecture doc gate + compliance: ACTIVE. Every code change needs an attached architecture doc logged in commit history; Vizier enforces creation, storage, and linkage before merges or saves. [Depends on: Outcome summaries, Commit isolation/gates]
- Session logging to filesystem: ACTIVE (MVP shipped). CLI now writes repo-local `.vizier/sessions/<id>/session.json` artifacts (transcripts, repo state, config snapshot, outcome) and surfaces the path in outcomes/commits; next steps are richer resume UX, redaction levers, and gate-aware checkpoints. [Depends on: Auditor facts, Outcome]
- TODO Garbage-Collection on save: ACTIVE. Vizier aggressively removes duplicate, superseded, empty, and orphaned TODOs during `vizier save` and after material TODO merges, with safety levers and clear Outcome reporting. [Depends on: Config, Auditor, VCS, file tracking, Snapshot Threads]
- Agent workflow orchestration: NEW. Operators want Vizier to act as the conductor for multi-agent runs (snapshot wording sign-off → architecture doc draft → implementation → code sign-off → `vizier save`), so the CLI/Auditor stack must expose those checkpoints and keep the VCS gates tight. [Cross: Commit isolation, Architecture doc gate, Outcome summaries]

Code state (behaviors that matter)
- Display/verbosity: vizier-cli wires -q/-v/-vv and --no-ansi into vizier-core::display; progress rendering is gated by stdout/stderr TTY and verbosity. Non‑TTY no longer leaks ANSI spinner frames; Info/Debug lines are governed by verbosity.
- stdout usage remains inconsistent; some commands (e.g., save, snapshot init, clean) emit ad‑hoc outcome lines, but there is no standardized outcome.v1 JSON or unified Outcome component yet.
- No explicit mode switch exists; protocol-style behavior is not yet implemented. `--json` prints conversation JSON in some paths but is not the outcome.v1 schema. JSON stream/eventing for Codex is present internally.
- No vizier-tui crate present; the chat TUI lives in `vizier-core/src/chat.rs` (alt-screen via ratatui). There is no diff-preview UI.
- Chat path now routes through the Auditor; diffs from chat‑initiated changes can be reported with A/M/D/R. Each CLI run now writes a structured session log to `.vizier/sessions/<session_id>/session.json` (timestamps, repo state, config snapshot, transcript, outcome) and references that path from commit bodies and Outcome lines; `--no-session` disables the writer when compliance requires it.
- CLI exposes global `--load-session <id>` and `--no-session` flags; `--load-session` now reads `.vizier/sessions/<id>/session.json` (falling back to the old config-dir format when needed) so operators can resume from repo-local artifacts rather than `$XDG_CONFIG_HOME`.
- Post‑action UX lacks a unified Outcome section; current ad‑hoc lines (e.g., "Save complete; …", snapshot bootstrap summary) are not standardized. Auditor facts for chat are available to drive a canonical epilogue. Outcome component remains a priority (CLI‑first with outcome.v1 JSON and stdout epilogue). Canonical TODO added.
- No built-in agent command: Vizier intentionally lacks a `vizier agent run` flow; operators launch Codex directly and handle branch/PR plumbing outside the CLI.
- AGENTS.md contract/log: Still a short reminder that directs agents to README, `.vizier/.snapshot`, prompts, and now the draft→approve→merge workflow doc; no dedicated decision log or interop schema yet.
- TODO GC not yet implemented; policy and levers defined; to be wired into save path and Auditor Outcome.
- Docs prompts exist: `vizier docs prompt <scope>` scaffolds/prints architecture prompt templates; the architecture‑doc compliance gate is not yet enforced.
- Policy prompts + remote runner contract: `vizier-core/src/lib.rs::SYSTEM_PROMPT_BASE` now bakes in the Default-Action Posture, commit-style summary guidance (assistant output as a concise Outcome line without dumping raw snapshot/TODO text), and a `vm_commands.sh` SSH remote-runner description; the helper script is referenced for operators but not yet wired into vizier-cli flows within this repo.
- Codex backend path now lives in `vizier-core/src/codex.rs`: the auditor spawns `codex exec --json --output-last-message` in the repo, streams progress events, captures token usage, falls back to the wire backend when Codex errors, and CODEX.md serves as the living rollout log for this flow. The runner now supports a passthrough output mode that drops `--json` and pipes Codex stdout/stderr straight to Vizier’s stderr while still harvesting the final assistant message via `--output-last-message`.
- Auditor commit plumbing now calls `FileTracker::sync_vizier_changes` before writing `.vizier` commits and returns early when nothing changed so Codex‑edited snapshot/TODO files get staged without disturbing pre‑existing staged code. Conversation commits were removed; session IDs + paths travel with the `.vizier` and code commits instead, while inline ask/clean flows still commit `.vizier` changes immediately (Pending Commit gate still pending).
- `vizier-cli` appends `(tokens: prompt=?, completion=?, total=?)` (or `unknown`) to the assistant summary line so token reporting is visible even when Codex supplies usage counts.
- Architecture doc compliance: no docs/architecture index exists and saves succeed without citing a doc, so there is no auditable linkage from code changes to architecture intent.
- `vizier draft` (Codex-only) provisions a `draft/<slug>` branch from the primary branch tip via a temporary worktree, runs Codex to generate `.vizier/implementation-plans/<slug>.md`, commits the plan on that branch, then cleans up the worktree so the operator’s checkout stays untouched while stdout reports the plan path/branch pairing.
- `vizier approve` implements the approved plan on the draft branch in a disposable worktree (Codex-backed), auto-commits the branch so reviewers can diff against the target, and now streams Codex’s raw stdout/stderr directly to the CLI’s stderr via passthrough mode (Codex usage recorded as `unknown`). `vizier merge` removes `.vizier/implementation-plans/<slug>.md`, refreshes `.vizier` state, then performs the non‑fast‑forward merge of `draft/<slug>` back onto the primary (or `--target`) with a metadata‑rich commit message (plan, branch, status, spec source, created_at, summary, optional notes). Approve supports `--list`, `-y/--yes`, `--target`, and `--branch`; Merge supports `-y/--yes`, `--delete-branch`, `--target`, `--branch`, and `--note`.
- Merge conflicts are now resumable: when libgit2 reports conflicts, Vizier materializes the merge index into the working tree, writes a resume token under `.vizier/tmp/merge-conflicts/<slug>.json`, and exits with guidance. Operators can resolve + rerun `vizier merge <slug>` to reuse the stored commit metadata, or pass `--auto-resolve-conflicts` to let Codex attempt a scoped auto-resolution before falling back to manual cleanup. Sentinel files are deleted automatically once the merge commits.
- Implementation-plan prompting now lives in `vizier-core/src/lib.rs::IMPLEMENTATION_PLAN_PROMPT`, and `vizier-core/src/codex.rs::build_implementation_plan_prompt` feeds Codex the snapshot, active threads, plan slug/branch metadata, and operator spec so the Markdown plan includes front-matter `{plan, branch, status:draft, created_at, spec_source}` plus “Operator Spec” and “Implementation Plan” sections.
- New VCS helpers (`detect_primary_branch`, `create_branch_from`, `add_worktree_for_branch`, `commit_paths_in_repo`, merge helpers, etc.) manage temporary worktrees under `.vizier/tmp-worktrees/` (now gitignored) so `vizier draft` can stage/commit plan files without touching the operator checkout, and enable clean non‑FF merges for approvals.
- `tests/src/lib.rs` exposes standard `#[test]` cases built on an `IntegrationRepo` fixture that clones `test-repo` + `.vizier` into per-test temp dirs, configures Git identity, and caches the release `vizier` binary via `OnceLock`. Coverage spans `vizier save` flows, approve/merge wiring, conflict auto-resolution, and sentinel creation without relying on a custom harness.
- `vizier-core/src/vcs.rs` tests use a `TestRepo` fixture plus repo-aware helpers (`stage_in`, `add_and_commit_in`, `push_current_branch_in`, `unstage_in`) instead of mutating the process CWD, so `cargo test -p vizier-core` runs at default parallelism without `--test-threads=1`.
- README.md documents `vizier draft`, `vizier approve` (implementation on the draft branch), and `vizier merge` (non‑FF merge with plan metadata) with accurate flags; copy updated to avoid drift. Dedicated DRAFT.md/APPROVE.md are still absent. [Cross: todo_README_add_approve_command.md]
- docs/workflows/draft-approve-merge.md now walks operators through the `vizier draft → vizier approve → vizier merge` choreography, covering prerequisites, Git effects, conflict sentinels, walkthrough, FAQ, and compliance tie-ins.
- Multi-agent workflows are ad-hoc: there is no structured runbook that walks operators through “discuss → snapshot sign-off → architecture doc draft → implement → code sign-off → save,” so intent can drift between agents and VCS gates.

Acceptance checkpoints (selected)
- Stdout/stderr contract: Non‑TTY emits no ANSI; stdout carries final results; stderr stays limited to errors/warnings per verbosity. Flags -q/-v/-vv and --no-ansi implemented; progress gated by TTY. outcome.v1 JSON not yet implemented; standardize across commands. [Active]
- Mode split: `--mode protocol` produces only structured JSON/NDJSON on stdout (no human prose), no ANSI in any environment, deterministic event ordering, and categorized exit codes. Chat mode remains default with human epilogue and optional `--json`/`--json-stream`. Closed-stdin never blocks. [Active]
- Pending Commit gate guards conversation changes with confirm_destructive=true and auto_commit=false.
- Conversation commits only touch .vizier; preserve pre-existing staged changes exactly (A/M/D/R).
- Non-interactive CLI requires explicit consent; never opens editor.
- Session JSON MVP: Minimal message log saved today under the user config directory on process exit; migrate to repo‑local `.vizier/sessions/<id>/session.json`, add atomic writes + schema validation, and include workflow metadata (workflow_type, thinking_level). [Pending]
- Outcome summaries: After each operation, users see a compact summary matching Auditor/VCS facts; assistant final mirrors it. For chat, the Auditor-backed A/M/D/R must be reflected in both human epilogue and outcome.v1 JSON. Deterministic final Outcome emission. [CLI-first]
- TODO GC on save: During `vizier save`, duplicate/superseded/empty/orphaned TODOs are deleted or staged for deletion per config; Outcome reports deletions with reasons; dry-run supported; protected items skipped. [Active]
- Architecture doc gate: Saves refuse to finalize without a cited architecture doc; outcomes and commits include the referenced path, and multi-agent runs share the same doc reference. [Planned]

Next moves
1) Stdout/stderr contract + verbosity: complete the contract by standardizing a stable stdout Outcome across commands and wiring an outcome.v1 JSON; keep spinner/ANSI gating as shipped. [Active]
2) Outcome component: implement outcome.v1 schema; include audited A/M/D/R, gate state, and (when applicable) {todo, branch, commit_count, pr_url}. Print to stdout on success; `--json`/stream variants. Ensure it fires after every chat/ask/save. [Active]
3) Mode split wiring: Add `--mode protocol` to CLI, thread through to core display/observer; enforce protocol-mode IO rules, exit codes, and metadata {mode:"protocol"}. Ensure closed-stdin safe behavior. [Active]
4) Chat and ask gate parity: Place assistant‑initiated edits (ask/chat) behind a Pending Commit gate instead of immediate commit; surface via Outcome/JSON. Preserve pre‑existing staged work. [Active]
5) TODO GC wiring: Add product‑level GC behavior into save path with config/flags; surface detailed Outcome facts and integrate with Pending Commit gate where enabled. [Active]
6) Session logging follow-ups: now that repo-local `.vizier/sessions/<id>/session.json` artifacts ship with each run, add resume/diff tooling, redaction levers, and schema validation so downstream agents can trust the record. [Active]
7) Architecture doc enforcement + history: Add compliance gates that require architecture docs for every code change, store doc references alongside commits, and surface discrepancies via Auditor/Outcome before merge. [New]
8) Agent workflow orchestration: Give operators a first-class workflow that sequences snapshot approval, architecture doc drafting, implementation, code sign-off, and final `vizier save`, with Auditor/Outcome breadcrumbs for each checkpoint. [New]
9) Draft approval plumbing: SHIPPED. `vizier approve` applies the plan on the draft branch; `vizier merge` merges that branch back onto the primary with a metadata‑rich non‑FF commit and optional branch deletion. Follow‑ups: standardize Outcome epilogue/JSON for approve/list/merge, add protocol‑mode parity, surface session paths. [Active]

Cross-links
- Output contract + Mode split ↔ Outcome summaries: the same event stream feeds human epilogues, protocol JSON, and chat results without ANSI leakage.
- DAP ↔ Outcome ↔ TODO GC: default-action edits update .vizier, GC keeps the garden tidy, and the Outcome line reports those edits.
- Commit isolation + gates ↔ Architecture doc compliance: pending commits and save gates must cite the architecture doc reference and surface it in outcomes/commits.
- Session logging ↔ Auditor facts: chat operations persist audited facts to session.json, and the Outcome epilogue points to the artifact for downstream tooling.
- Agent workflows ↔ Commit/Doc gates: the same checkpoints that gate architecture docs and pending commits must be surfaced as workflow steps so multi-agent runs stay aligned and auditable.

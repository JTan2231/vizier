# Glossary

- **A/M/D/R**: Auditor change buckets: Added / Modified / Deleted / Renamed.
- **`cap.agent.invoke`**: Canonical agent executor capability ID; runtime primitive that reads one prompt artifact and streams assistant output/telemetry without inline prompt construction.
- **Auditor**: Component that records run facts, summarizes repo edits, and writes session metadata.
- **Change discipline**: AGENTS.md contract that code changes must update docs/tests and pass `./cicd.sh`.
- **Clean scope expansion**: `vizier clean <job-id>` resolves to one job by default, or to the full workflow run scope when the requested job record carries `metadata.workflow_run_id`.
- **Clean safety guard**: Cleanup refusal contract (exit `10`) when scoped jobs are active or when non-scoped active jobs depend on scoped jobs via `after` or artifact-only producer sets.
- **Clean degraded outcome**: Best-effort cleanup state where at least one scoped item could not be removed safely (for example unsafe worktree path or filesystem failure); non-zero exit unless `--force`.
- **Clap unknown-subcommand path**: Standard parser failure surface used for removed commands; no custom migration text.
- **Code state**: Snapshot slice for user-visible behavior, interfaces, and constraints.
- **Commit-style summary**: User-facing one-line narrative maintenance response; detailed deltas stay internal.
- **Conventional-subject release-note filter**: `vizier release` includes notes only for Conventional Commit subject lines.
- **Current worktree evidence**: Snapshot code-state line that records the latest local `draft/*` branch inventory plus on-disk and tracked-deletion `.vizier/implementation-plans/*.md` evidence for the active worktree slug (including explicit no-deletion states).
- **Worktree evidence label**: Parenthetical in the current-worktree-evidence snapshot bullet (`draft/<slug>`, `revalidated <date>`) that identifies which live branch inventory the evidence was sampled from.
- **Default-Action Posture (DAP)**: Narrative upkeep default where turns update snapshot/glossary unless explicitly opted out.
- **Durable init markers**: `.vizier/narrative/snapshot.md` and `.vizier/narrative/glossary.md`.
- **Empty plan-doc inventory signal**: Evidence state where `.vizier/implementation-plans/` has no on-disk `.md` plan docs in a worktree (including when the directory itself is absent); used with branch inventory to quantify legacy drift.
- **Mixed plan-doc inventory signal**: Evidence state where `.vizier/implementation-plans/` has at least one on-disk plan doc while also carrying tracked deletions (`D .vizier/implementation-plans/<slug>.md`), signaling overlapping historical drift shapes in one worktree.
- **Executor class metadata**: Scheduler/job metadata fields `workflow_executor_class` + `workflow_executor_operation` (with optional `workflow_control_policy`) that define canonical workflow identity for scheduler/job records.
- **Execution-root metadata**: Job metadata field `execution_root` representing the logical filesystem root for workflow-node runtime (`.` = repo root).
- **Execution-root edge propagation**: Runtime behavior that copies execution context (`execution_root` + worktree ownership fields) along explicit workflow routes before downstream queue/retry handling.
- **Succeeded-edge atomic completion lock**: Workflow-node completion ordering where succeeded nodes perform source finalization, success-route context propagation, and one scheduler advancement inside a single `SchedulerLock` critical section so concurrent ticks cannot start successors before context persistence.
- **Execution-root reset contract**: Cleanup/retry rule where successful worktree cleanup resets `execution_root` to `.` and clears `worktree_*` ownership fields; degraded cleanup preserves context for recovery.
- **Implicit workflow lock inference**: Queue-time compile behavior where lockless canonical workflow nodes infer exclusive branch locks from args/artifacts/node-owned lock-scope context and use `repo_serial` when no branch scope is discoverable.
- **Node-owned lock-scope context**: Queue-time lock-inference ownership map where root-authored nodes use root template params and imported composed nodes use imported-stage params only, preventing cross-stage branch-scope leakage.
- **Effective workflow locks**: The resolved per-node lock set used by scheduler enqueue (`JobSchedule.locks`) after explicit override or implicit inference resolution.
- **`repo_serial` fallback lock**: Default exclusive lock key emitted by compile for lockless nodes with no branch context.
- **Git CLI invocation guard**: Codebase invariant that `rg -n 'Command::new\\(\"git\"\\)' vizier-core/src vizier-cli/src vizier-kernel/src tests/src` stays empty so runtime/test Git behavior cannot regress to shelling out.
- **Libgit2-only workflow Git runtime**: Runtime/test posture where worktree/merge/stage/patch/retry-cleanup Git flows execute through `vizier-core/src/vcs/*` helpers and `git2` APIs instead of `git` subprocesses.
- **Linked-worktree checkout fallback**: Branch-switch behavior that detaches HEAD before reattaching to a target branch when libgit2 rejects direct checkout because the branch is already the HEAD of a linked worktree.
- **Force-equivalent shared-branch worktree add**: `worktree.prepare` parity path that creates a temporary-branch worktree and repoints its HEAD to the requested branch so multiple linked worktrees can intentionally track the same branch.
- **Patch hunk-origin reconstruction**: Diff-print rule that re-adds `+`, `-`, and space origins to emitted patch lines so generated patches remain parseable by libgit2 patch-apply APIs.
- **Executor-first workflow model**: Internal template contract where each executor node declares exactly one executor class (`environment.builtin`, `environment.shell`, or `agent`) and control behavior is modeled separately.
- **Explicit `uses` declaration**: Validator rule that executor/control node identity must be declared via recognized `uses` IDs; unknown arbitrary labels are rejected (no implicit custom-command fallback).
- **`gen-man` drift gate**: `cargo run -p vizier --bin gen-man -- --check` validation that generated man pages are current.
- **Help pager contract**: Help text auto-pages only on TTY via `$VIZIER_PAGER` (or fallback pager), prints directly on non-TTY, and can be internally suppressed with hidden `--no-pager`.
- **HCL placeholder escaping**: Workflow templates authored in `.hcl` must write literal Vizier queue-time placeholders as `$${key}` so HCL decoding yields `${key}` for existing expansion logic.
- **Init check mode**: `vizier init --check`; validates the init contract without mutating files.
- **Jobs command surface**: Retained `vizier jobs` operations (`list`, `schedule`, `show`, `status`, `tail`, `attach`, `approve`, `reject`, `retry`, `cancel`, `gc`) over persisted job records.
- **Jobs raw monitoring mode**: Additive `vizier jobs list|show|schedule --format json --raw` path that emits typed monitoring envelopes (`version`, `generated_at`) instead of display-field-flattened JSON.
- **Jobs raw JSON gate**: Contract that `--raw` is accepted only with explicit `--format json`; non-JSON or missing-format usage fails fast with CLI errors.
- **Jobs ownership split**: Scheduler/job/workflow runtime side effects now live in `vizier-core/src/jobs/mod.rs`; `vizier-cli/src/jobs.rs` is a compatibility re-export shim used by existing CLI call sites.
- **Global workflow directory**: Default implicit alias source for `vizier run <flow>` at `<base_config_dir>/vizier/workflows` (or `[workflow.global_workflows].dir` override) when `[workflow.global_workflows].enabled = true`.
- **Stage alias map**: Repo-local `[commands]` config mapping (for example `draft`, `approve`, `merge`) that resolves `vizier run <alias>` to workflow file selectors.
- **Stage-template drift repair**: Repo-local recovery where `.vizier/config.toml` re-adds `[commands].draft|approve|merge` alias selectors and `.vizier/workflows/{draft,approve,merge}.hcl` is restored from legacy `vizier.*` `uses` labels to canonical `cap.env.*`/`cap.agent.invoke`/`control.*` DAGs, including draft cleanup via explicit `after` from `stage_commit` and merge CI gate terminal settling for operator-driven retries.
- **Merge gate settle path**: Merge-stage template posture where `merge_gate_cicd` failures end as terminal `failed` jobs (no self-loop retry edge), so recovery uses explicit `vizier jobs retry <job_id>`.
- **Primitive stage templates**: Canonical stage DAG files (`.vizier/workflows/draft.hcl`, `.vizier/workflows/approve.hcl`, `.vizier/workflows/merge.hcl`) executed through `vizier run` + scheduler jobs; no wrapper commands.
- **`vizier run` orchestrator**: Public workflow front-door that resolves a flow source, compiles/validates template nodes, enqueues scheduler jobs, and optionally follows to terminal state.
- **Legacy plan artifact drift**: Residual mismatch where `draft/*` branches and `.vizier/implementation-plans/*.md` files no longer align after workflow-command removal.
- **Live plan-doc deletion signal**: A tracked `D .vizier/implementation-plans/<slug>.md` state used as evidence that branch/doc inventories are diverging in a worktree.
- **Local `--follow` flag**: Follow mode is command-local on `vizier jobs tail --follow`; no global `--follow` remains.
- **Man-page taxonomy**: Installed sectioned docs under `man1` (`vizier`, `vizier-jobs`), `man5` (`vizier-config`), `man7` (`vizier-workflow`).
- **Canonical uses-only contract**: Workflow template identity policy that accepts only `cap.env.*`, `cap.agent.invoke`, and `control.*` `uses` IDs; legacy `vizier.*`, legacy non-env `cap.*`, and unknown labels fail validation immediately.
- **Canonical runtime operation inventory**: The full runtime dispatch set behind `__workflow-node`: 16 executor operations (`prompt.resolve`, `agent.invoke`, worktree/plan/git/patch/build/sentinel/shell ops) plus 5 control policies (`gate.stop_condition`, `gate.conflict_resolution`, `gate.cicd`, `gate.approval`, `terminal`) with no canonical placeholder fallthrough.
- **Legacy workflow capability field**: Historical job metadata key `workflow_capability_id`; retained for deserializing old records but no longer treated as active identity for new scheduler output.
- **Narrative state**: Snapshot slice covering active themes, tensions, and open/retired threads.
- **No-update signal**: Explicit turn-level instruction (`no-op:`, `discuss-only:`, or equivalent) that suppresses narrative edits.
- **Reduced CLI surface**: Supported top-level commands: `help`, `init`, `list`, `cd`, `clean`, `jobs`, `run`, `audit`, `completions`, `release`.
- **Removed command family**: Hard-removed top-level commands: `save`, `draft`, `approve`, `review`, `merge`, `test-display`, `plan`, `build`, `patch`.
- **Pager flag regression guard**: CLI/docs/tests invariant where help auto-pages only on TTY via `$VIZIER_PAGER` (or fallback), non-TTY help prints directly, explicit `--pager` is rejected, and hidden `--no-pager` remains internal.
- **Removed global flags**: Hard-removed globals: `--agent`, `--push`, `--no-commit`, `--follow`, `--pager`, `--background-job-id`.
- **Repo boundary**: Agent work stays inside the repository unless explicit authorization says otherwise.
- **Retired workflow threads**: Narrative docs preserved for historical context after hard-removal of workflow/agent command families.
- **Prompt artifact contract**: Canonical prompt payload wiring for executor templates: one custom artifact shaped `custom:prompt_text:<key>` produced by prompt-resolve nodes and consumed by canonical invoke nodes.
- **Composed prompt placeholder suffix alias**: `prompt.resolve` runtime fallback that exposes unique composed-node suffix args under legacy node-id placeholder keys (for example `develop_draft__persist_plan.name_override` also resolves as `persist_plan.name_override`).
- **Prompt payload data store**: Optional typed JSON payload files for custom artifacts under `.vizier/jobs/artifacts/data/<type_hex>/<key_hex>/<job_id>.json`; scheduler gating still keys off marker files.
- **Running-job PID liveness reconciliation**: Driver-side scheduler/follow behavior that probes `status=running` records before waiting/decision evaluation and terminalizes stale jobs as explicit `failed` outcomes.
- **Process liveness metadata**: Additive `JobMetadata` fields `process_liveness_state`, `process_liveness_checked_at`, and `process_liveness_failure_reason` written when stale-running reconciliation finalizes a job.
- **Process identity mismatch state**: Stale-running liveness state `stale_identity_mismatch` used when a live PID fails identity checks (PID reuse or mismatched worker identity) during reconciliation.
- **Operation-output artifact (`custom:operation_output:<node_id>`)**: Implicit reserved custom artifact contract published by every workflow runtime node, backed by standard custom marker/data paths for downstream `needs` and payload reads.
- **Operation-output payload (`vizier.operation_output.v1`)**: Normalized per-node runtime payload containing run/job/node identity, executor/control identity, outcome/exit code, stdout text, stderr lifecycle+diagnostic lines, timing fields, and structured operation result details.
- **Prompt-resolve node**: Environment executor node (`cap.env.builtin.prompt.resolve` or `cap.env.shell.prompt.resolve`) that outputs exactly one prompt artifact for downstream `cap.agent.invoke`.
- **Runtime execution root resolution**: Workflow-node rule that resolves handler roots by precedence (`metadata.execution_root` -> repo root) with repo-boundary validation; legacy-only `metadata.worktree_path` metadata is rejected with migration guidance.
- **Sink policy (`terminal`)**: Canonical control-node contract where terminal nodes must have no outgoing routes; configured outgoing edges are treated as runtime failure.
- **Release dry run**: `vizier release --dry-run` preview mode for version bump and notes without commit/tag creation.
- **Release gate script**: Optional `vizier release` post-mutation command configured by `[release.gate].script`, overridable with `--release-script <cmd>`, suppressible with `--no-release-script`, and executed from repo root with `VIZIER_RELEASE_VERSION`, `VIZIER_RELEASE_TAG`, `VIZIER_RELEASE_COMMIT`, and `VIZIER_RELEASE_RANGE`.
- **Release transaction rollback**: Script-failure recovery contract for `vizier release` that deletes the created release tag (if any), resets the original branch to the recorded start commit, and hard-restores index/worktree state.
- **Session log**: Per-run artifact at `.vizier/sessions/<id>/session.json` when session logging is enabled.
- **Snapshot**: Canonical project frame in `.vizier/narrative/snapshot.md`.
- **snapshotDelta**: Internal narrative-diff artifact not printed in user-facing responses.
- **Steady-state inventory refresh**: Worktree inventory refresh where branch/doc/deletion evidence is unchanged from the previous reading; records freshness without introducing a new drift shape.
- **Thread doc**: Focused narrative file under `.vizier/narrative/threads/` for one tension.
- **Worktree**: Separate checkout under `.vizier/tmp-worktrees/`.
- **Worktree inventory refresh**: Periodic evidence check that captures local `draft/*` branches, on-disk `.vizier/implementation-plans/*.md` files, and tracked plan-doc deletions for the current worktree slug so legacy drift reporting stays current.
- **Workspace command (`cd`)**: Deprecated-but-retained worktree helper that still fails intentionally on invocation.
- **`__workflow-node` entrypoint**: Hidden scheduler-only CLI command (`vizier __workflow-node --job-id <id>`) that executes one compiled workflow node and finalizes its job record.
- **Workflow node runtime metadata**: Job metadata fields `workflow_run_id`, `workflow_node_attempt`, `workflow_node_outcome`, and `workflow_payload_refs` used by runtime node execution and retry rewinds; workflow jobs may also carry `execution_root` + worktree ownership context.
- **Workflow run manifest**: Queue-time runtime file `.vizier/jobs/runs/<run_id>.json` containing per-node executor/control identity, args, retry policy, routing targets, and outcome artifact maps.
- **Workflow runtime bridge**: Internal execution layer that compiles canonical templates to scheduler jobs, dispatches node handlers through `__workflow-node`, and routes outcomes without exposing removed public workflow commands.
- **Workflow runtime I/O contract**: `__workflow-node` runtime guarantee that all canonical executor operations/control policies emit lifecycle/progress diagnostics on `stderr`, operational output on `stdout`, and persist normalized operation-output payloads for downstream consumption.
- **Run flow resolution order**: `FLOW` lookup contract: explicit `file:`/path, then `[commands]` alias, then canonical selector lookup (`template.name@vN`); unresolved flow names fail (no implicit repo/global fallback discovery).
- **Run flow-scoped help**: `vizier run <flow> --help` path that resolves flow through the same alias/file/selector contract as enqueue/check and renders workflow-specific `Workflow`/`Usage`/`Inputs`/`Examples`/`Run options` output.
- **Run entry-input CLI preflight error**: Missing required root-input guidance emitted as `error`/`usage`/`example`/`hint`, with alias-aware usage/examples and without internal node/capability identifiers.
- **Run check mode**: `vizier run --check <flow>` validate-only path that executes queue-time checks (resolve/load/expand/coerce/preflight/capability/compile) and exits without generating run IDs, writing run manifests, enqueueing jobs, or ticking the scheduler.
- **Run check conflict set**: `vizier run --check` rejects enqueue/runtime-only flags (`--follow`, `--after`, `--require-approval`, `--no-require-approval`, `--repeat`) so validation-only execution cannot mutate scheduler state.
- **Schedule raw typed wait**: `vizier jobs schedule --format json --raw` row contract where `wait` is nullable typed `{kind, detail}` (versus flattened string in non-raw schedule JSON), while `edges` preserve parity with existing schedule JSON.
- **Workflow audit mode**: `vizier audit <flow>` read-only queue-time analysis path that reuses run/check preprocessing + validation and reports output artifacts plus untethered inputs (with consumer node IDs) without enqueue/runtime side effects.
- **Workflow audit effective-lock map**: Additive `vizier audit` output field (`effective_locks`) listing per-node effective locks from the same queue-time compile path used by enqueue.
- **Untethered input**: A workflow `needs` artifact with zero in-template producers; surfaced by `vizier audit` and optionally promoted to exit `10` with `--strict`.
- **Run `--set` Phase 1 surface**: Queue-time interpolation coverage for `vizier run --set` across `nodes.args`, artifact payloads (`needs`/`produces`), lock keys, custom precondition args, gate script/custom fields, gate bools, retry mode/budget, and artifact-contract IDs/versions.
- **Run `--set` strict coercion**: Queue-time typed coercion for expanded placeholders: bool tokens (`true|false|1|0|yes|no|on|off`), retry budget as decimal `u32`, and retry mode via canonical enum parsing; failures are field-path errors that prevent enqueue.
- **Run `--set` topology deferral**: Explicitly deferred interpolation scope for topology/identity fields (`after`, `on`, template `id/version`, imports, links) pending deterministic-graph policy decisions.
- **Run root overrides**: `vizier run` queue-time root-job schedule overrides: external `--after` dependencies and approval policy toggles (`--require-approval` / `--no-require-approval`).
- **Run grouped `--after` reference**: `vizier run --after run:<run_id>` queue-time expansion that reads `.vizier/jobs/runs/<run_id>.json`, selects success-terminal sink nodes (`routes.succeeded` empty), and converts the reference to concrete `schedule.after[*].job_id` dependencies.
- **Run bare-id `--after` rejection**: CLI guard that rejects bare `run_<id>` tokens for `--after` and instructs operators to use `run:<run_id>` when targeting workflow runs.
- **Run follow exit contract**: `vizier run --follow` aggregate terminal mapping: `0` all succeeded, `10` blocked-only terminal set, non-zero when any failed/cancelled job is terminal.
- **Run repeat chaining**: `vizier run --repeat <N>` queue-time behavior that enqueues `N` unique runs and appends prior-run success-sink dependencies (`run:<prev_run_id>`) for iterations `i>1` so repeats execute serially.
- **Run repeat aggregate payload**: Multi-run JSON/text summary shape used when `repeat>1` (`workflow_runs_enqueued` / `workflow_runs_terminal`, `repeat`, and ordered per-run records) while `repeat=1` keeps the single-run payload contract.
- **Run repeat follow short-circuit**: Repeat follow policy where runs are observed in enqueue order and follow returns immediately on the first non-success terminal run (`blocked` or `failed`), preserving deterministic exit codes.

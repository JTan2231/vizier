Running Snapshot — updated

Narrative theme
- Reduce operator friction: conversational intent is authorization to evolve the project. The assistant maintains a living snapshot and task list by default; users can explicitly opt out per turn.
- Editorial housekeeping: Narrative artifacts now live under `.vizier/narrative/` (snapshot, glossary, and thread docs); legacy TODO files were migrated and the save path should enforce garbage-collection to keep a single canonical thread per tension.
- Direct narrative edits: Narrative upkeep is done by editing `.vizier/narrative/` files in-repo (no Vizier CLI invocations), staying within repo boundaries (no parent-directory access) and avoiding network access unless explicitly authorized, while keeping snapshot + glossary in lockstep as the canonical story surfaces.
- Operational bounds: All agent work stays within the repo boundary and avoids parent-directory access or network use unless the user explicitly authorizes it; this applies to code, docs, and narrative work alike.
- Explicit-instruction guardrail: AGENTS.md requires explicit instruction before editing `.vizier/narrative/`; until precedence is codified, narrative upkeep is treated as opt-in per explicit instruction even when DAP would otherwise apply, and that authorization covers snapshot/glossary plus supporting thread docs as needed; current task format explicitly calls out "Update the snapshot, glossary, and supporting narrative docs as needed" to satisfy the guardrail, and its absence means the turn is a narrative no-op.
- Codex-integrated posture: Codex now handles the heavy agent work directly, so Vizier trims internal orchestration threads and focuses on snapshot accuracy plus CLI guardrails.
- Pluggable agent posture: Vizier must treat “agent” as a swappable backend (Codex today, Claude and others next) with a stable interface for capabilities, prompts, and telemetry, so plan/approve/review flows don’t have to be rewritten each time a new CLI agent is introduced.
- Config-first posture: Treat configuration as a first-class surface above Git and external agents; new features should ship with repo/CLI knobs and sensible defaults so operators are not forced into an overly opinionated workflow but still get high utility out of the box.
- Lean backlog: Threads that do not protect Codex-era workflows were culled; the remaining arcs prioritize IO contracts, auditability, and documentation gates.
- Bureaucratic enforcement: Treat Vizier as the compliance enforcer for large-organization processes (architecture docs per change, auditable histories, PR-ready artifacts).
- Change discipline: AGENTS.md explicitly reiterates that code changes must update tests/docs and pass the repo’s `./cicd.sh` checks before they’re treated as done.
- Story-editor discipline: Snapshot updates are read-before-write, diff-like merges that convert conversations into concrete plot points (not parallel “investigate X” tasks), cross-link to existing threads, stay evidence-backed, and remain product-level by default (pointer anchors when useful; implementation detail only when required by safety/compliance or explicit request). Glossary updates stay in lockstep; see `vizier-core/src/lib.rs::SYSTEM_PROMPT_BASE` for the abstraction rules.
- Snapshot framing: The snapshot is a single authoritative frame at time T with two slices—Code state (user-visible behavior and constraints) and Narrative state (active themes, tensions, and open threads). Updates should preserve that split and stay product-level unless safety/compliance or explicit request demands detail.
- Context recovery: When users say they’re forgetting context, respond by surfacing the relevant snapshot slice and active threads to re-anchor the conversation before proceeding.
- Orientation discipline: Agents are expected to reread `.vizier/narrative/snapshot.md`, README, and the prompt scaffolding (especially `docs/prompt-config-matrix.md` as the canonical map of prompt scopes/kinds/levers and `docs/config-reference.md` as the full configuration catalogue with override examples), and to scan the current implementation for architectural/styling patterns before planning so every run starts grounded in the current story; AGENTS.md and `vizier plan` (echoes resolved settings) provide the fast orientation path.
- Human-only docs guardrail: AGENTS.md reiterates that README.md and AGENTS.md remain human-authored, so agents treat them as read-only orientation surfaces unless a human explicitly directs otherwise.
- Snapshot-first prompting: Documentation/review prompt text now speaks only about keeping the snapshot current (no narrative-doc output), while narrative docs remain optional context via `<narrativeDocs>` when enabled and the base prompt in `vizier-core/src/lib.rs` reflects that scope.
- Snapshot bootstrap pragmatism: `vizier init-snapshot` is treated as a forward-looking framing tool rather than a demand to reconstruct full project history; existing repositories are encouraged to "start where they are" with minimal, current-state notes, while new projects/features can opt into richer initial snapshots when that feels useful.
- Commit-style epilogues: Assistant-facing responses collapse to a single, commit-message-like Outcome line that reports what changed; detailed snapshot/narrative deltas, snapshotDelta output, and outcome JSON stay machine-oriented inside .vizier rather than being printed verbatim.

Active threads
- Stdout/stderr contract + verbosity: ACTIVE (partially shipped). CLI now supports -q/-v/-vv and --no-ansi, spinner rendering has been ripped out entirely, and vizier-core::display only emits line-based history that honors verbosity/TTY without any `--progress` flag. Codex JSON events end up as `[codex] phase — message` lines that respect quiet/verbosity so every ask/save/approve flow leaves a readable trace. The remaining work is to standardize a stable stdout Outcome line/JSON (outcome.v1) across commands and ensure stderr stays limited to errors/progress. [Cross: Outcome summaries; see: .vizier/narrative/threads/stdout_stderr_contract_and_verbosity.md]
- Mode split: Human-first CLI vs Protocol Mode v1: ACTIVE. Default CLI output stays human-first with readable epilogues; Protocol mode is machine-first with structured JSON/NDJSON on stdout, no ANSI, deterministic ordering, and categorized exit codes. Planned toggle `--mode protocol` (not yet implemented); JSON stream will share the same event contract as the human-mode CLI output. [Cross: Stdout/stderr, Outcome summaries]
- Commit isolation + gates: ACTIVE. Conversation- and agent-sourced changes are staged behind a Pending Commit gate; assistant flows must funnel through the Auditor before commits land. [Depends on: Outcome summaries, Session logging]
- Git hygiene + commit practices: ACTIVE. Vizier’s commit flows (for code, `.vizier`, and narrative changes) emphasize gating and session logging but lack a clear, documented story for commit boundaries, message style, and how agent-authored commits should look alongside human history; we need consistent practices for what gets committed when and how commit subjects/bodies and trailers communicate intent, sessions, and any required gates. [Cross: Commit isolation + gates, Architecture doc gate + compliance; see: .vizier/narrative/threads/git_hygiene_and_commit_practices.md]
- Default-Action Posture (DAP): ACTIVE. By default, snapshot and narrative docs update on every user input unless the user opts out per-turn (e.g., prefixing “no-op:” or “discuss-only:”). AGENTS.md now states narrative edits require explicit instruction, so we need to reconcile the opt-in guardrail with DAP’s default-action promise and document precedence. Stopgap: treat explicit instruction as a prerequisite for narrative edits until precedence is codified. CLI surfaces a one-line Outcome whenever DAP acts. [Cross: Outcome summaries; see: .vizier/narrative/threads/default_action_posture.md]
- Outcome summaries: ACTIVE. A unified human epilogue and outcome.v1 JSON must reflect Auditor A/M/D/R facts and gate state after every action. [Depends on: Auditor]
- Architecture doc gate + compliance: ACTIVE. Every code change needs an attached architecture doc logged in commit history; Vizier enforces creation, storage, and linkage before merges or saves. [Depends on: Outcome summaries, Commit isolation/gates]
- Session logging to filesystem: ACTIVE (MVP shipped). CLI now writes repo-local `.vizier/sessions/<id>/session.json` artifacts (transcripts, repo state, config snapshot, outcome) and surfaces the path in outcomes/commits; each outcome now carries a `token_usage` totals+delta block so auditors can reconcile the CLI epilogue. `vizier test-display --session` now records the agent context so session logs capture the resolved scope. Next steps are richer resume UX, redaction levers, and gate-aware checkpoints. [Depends on: Auditor facts, Outcome]
- Narrative Garbage-Collection on save: ACTIVE. Vizier should aggressively remove duplicate, superseded, empty, and orphaned narrative entries during `vizier save` and after material thread merges, with safety levers and clear Outcome reporting. [Depends on: Config, Auditor, VCS, file tracking, Snapshot Threads]
- Agent workflow orchestration: ACTIVE. Operators want Vizier to act as the conductor for multi-agent runs (snapshot wording sign-off → architecture doc draft → implementation → review/fix sign-off → `vizier save`), so the CLI/Auditor stack must expose those checkpoints and keep the VCS gates tight. `vizier review` now provides the dedicated critique/fix checkpoint with configurable check commands, review artifacts, and plan-status metadata, and the implementation-plan/review/merge prompts are now repo-configurable via the prompt store, but we still need the broader conductor story (architecture-doc gate, pending-commit orchestration, workflow UI) plus a tamer flag surface for the rest of the plan workflow, and a codified CI/CD gate whose checks must pass before an agent-backed command is treated as successful. The merge step now wires that gate via `[merge.cicd_gate]` plus per-run overrides (`--cicd-script`, `--auto-cicd-fix`, `--no-auto-cicd-fix`, `--cicd-retries`) so merges cannot complete until the repo-defined script exits 0 (with Codex remediation when enabled), but we still need gate metadata flowing into Outcome summaries/session logs and reusable gate profiles for ask/save/draft/approve/review. [Cross: Commit isolation, Architecture doc gate, Outcome summaries; see: .vizier/narrative/threads/draft_approve_merge_config_surface.md, .vizier/narrative/threads/agent_command_cicd_gate.md]
- Workspace/worktree management for plan branches: ACTIVE (reassessment). The DAG scheduler now owns temp worktrees, and `vizier cd`/`vizier clean` are deprecated + error out, so we need a scheduler-aware way to browse/edit draft branches (attach/detach, inventory surfacing) without reviving the old workspace manifests. [Cross: Agent workflow orchestration, draft→approve→merge config]
- Agent backend abstraction + pluggable CLI agents: ACTIVE. Vizier exposes scoped `[agents.default]`/`[agents.<command>]` config tables plus CLI overrides so each command (`ask`, `save`, `draft`, `approve`, `review`, `merge`) resolves its own `AgentSettings` (selector and runtime bounds) mapped to a runner/display pair. Only agent/gemini stacks remain: scopes now pick a bundled shim via a canonical `agent = "codex"|"gemini"|<custom>` selector (with optional `[agents.<scope>.agent].command` overrides) while CLI users drive the same choice via `--agent` instead of the deprecated `--backend`. Wire/model/reasoning/fallback keys still hard-error when present. Next steps are to surface capability discovery and per-selector options (so non-Codex agents can advertise which flows they support), finish backend-neutral progress/telemetry adapters, and allow fully pluggable CLI agents without rewriting the draft/approve/review workflow. Prompt templates (base/commit plus implementation-plan/review/merge-conflict) already flow through the config store so selector swaps inherit repo-specific instructions. [Cross: Agent workflow orchestration, Agent backend path in Code state; see: .vizier/narrative/threads/pluggable_agent_backends.md]
- Configuration posture + defaults: ACTIVE. Configuration is treated as a first-class surface above Git and external agents; new features and threads should expose their levers through a coherent config story with repo/CLI knobs and sensible defaults, so operators get a high-utility but non-imposed experience while still satisfying governance and workflow constraints. The agent selector rewrite moved `backend`/`label` into a single `agent = "<shim>"` knob (plus CLI `--agent`) and refreshed `example-config.toml`, the config reference, and the plan workflow doc accordingly. [Cross: Agent workflow orchestration, Agent backend abstraction + pluggable CLI agents, Architecture doc gate + compliance, Stdout/stderr contract + verbosity; see: .vizier/narrative/threads/configuration_posture_and_defaults.md]
- Snapshot bootstrap ergonomics (`vizier init-snapshot`): ACTIVE. `vizier init-snapshot` is the remaining bootstrap entrypoint, but injecting a canonical snapshot into mature projects remains awkward; operators feel pressure to summarize existing history before leaning on agents. We need a forward-looking bootstrap story where init-snapshot is encouraged for new repos/features and existing projects can "start where they are" with lightweight, present-focused notes instead of full retrospectives. [Cross: Snapshot-first prompting, Narrative storage, README bootstrap examples; see: .vizier/narrative/threads/snapshot_bootstrap_and_init_snapshot.md]

Code state (behaviors that matter)
- Agent selector unification: `example-config.toml`, `docs/config-reference.md`, and the workflow doc now show the canonical `agent = "<selector>"` key (default `codex`) plus optional `[agents.<scope>.agent]` command overrides, replacing the older `backend` + `agent.label` duo. CLI overrides follow the same shape via `--agent`/`--agent-command`, while the legacy `--backend` flag is now deprecated and prints a warning before translating to selectors. Tests cover config layering, plan JSON output (`agent` + `backend` fields), and buffered runner behavior under the new settings. The sample config + plan recap now explicitly warn that the root `agent` scalar and `[agent]` table are mutually exclusive, so custom-runner instructions no longer lead to invalid TOML.
- Config parser cleanup: `vizier-core/src/config.rs` now matches only the concrete `BackendKind` variants when translating deprecated `backend` keys and inspects the root `agent` entry via `as_str()`/`parse_agent_runtime_override`, eliminating the unreachable-pattern warnings that `cargo check` used to emit for both paths.
- Display/verbosity: vizier-cli wires -q/-v/-vv and --no-ansi into vizier-core::display, spinner rendering has been removed entirely, and progress is now always line-based with Info/Debug lines gated purely by verbosity (quiet fully suppresses history). Non‑TTY never sees ANSI artifacts.
- Help output now uses a TTY-aware pager: `--pager`/`--no-pager` and `$VIZIER_PAGER` control paging, while `--no-ansi` strips ANSI from help text; quiet/`--json` and non‑TTY suppress the pager and print directly.
- Narrative storage: `.vizier/narrative/snapshot.md` is the canonical snapshot, `.vizier/narrative/glossary.md` is the canonical glossary, and thread docs live under `.vizier/narrative/threads/`; legacy `.vizier/.snapshot` and `.vizier/todo_*` files were removed during migration.
- Narrative pairing: Agent prompts treat snapshot+glossary updates as a coupled surface; narrative upkeep now expects the glossary to be updated whenever the snapshot changes (not just during `vizier save`), and `vizier save` still fails when the snapshot changes but the glossary does not, keeping narrative edits consistent across workflows.
- Codex progress history: Instead of an overwriting spinner, every Codex event now renders to stderr as `[codex] <phase> — <message>` with percentage, status, and any detail/path gleaned from the event payload (`phase`, `label`, `message`, `detail`, `data.path`, `progress`, `status`, `timestamp`). Quiet mode suppresses the stream, while `-v/-vv` add timestamps and the raw JSON for auditing. `vizier approve` and Codex-powered conflict auto-resolution now share the same renderer instead of streaming raw stdout.
- stdout usage remains inconsistent; some commands (e.g., save, snapshot init, clean) emit ad‑hoc outcome lines, but there is no standardized outcome.v1 JSON or unified Outcome component yet.
- No explicit mode switch exists; protocol-style behavior is not yet implemented. `--json` prints conversation JSON in some paths but is not the outcome.v1 schema. JSON stream/eventing for Codex is present internally.
- Scheduler-backed execution + job records: Assistant commands now always enqueue DAG jobs (foreground execution is gone; `--no-background` errors), `--follow` attaches to job logs, and `--json` is rejected for scheduled runs. Job records now carry `child_args` plus `schedule` metadata (dependencies, locks, artifacts, pinned head, wait reason), and statuses include queued/waiting_on_deps/waiting_on_locks/blocked_by_dependency to keep wait states observable. Launching a detached job still prints the multi-line `Outcome: Background job started` block on stdout (stopgap until the stdout/stderr Outcome contract is standardized). Background job finalization flushes stdout/stderr before marking jobs complete so `vizier jobs tail --follow` and log readers capture the final assistant output. Job metadata (scope/target/plan, agent/backend/config snapshot, agent exit codes, session/outcome paths) still lives under `.vizier/jobs/<id>/{job.json,outcome.json,stdout.log,stderr.log}`, and `vizier jobs` continues to offer `status`, `tail`, `attach`, `cancel`, and `gc` actions with labeled log streaming; cancellation sends SIGTERM and marks jobs cancelled (exit 143) while GC prunes finished jobs past the retention window.
- Ask/save scheduling: ask/save run in disposable worktrees under a pinned head and serialized repo lock; successful runs cherry-pick a single commit back onto the target branch when the pinned head still matches and the worktree is clean.
- Merge queue removal: merge serialization now comes from scheduler locks; merge-queue config/state files are gone.
- Interactive chat command removed; the former alt-screen UI and its supporting modules (`vizier-core/src/chat.rs`, `vizier-core/src/editor.rs`) were deleted, so all work happens through CLI commands (ask/draft/save/approve/review/merge) with no diff-preview surface.
- Commit confirmation detours were removed end-to-end: the `--require-confirmation` flag, chat/editor prompts, and run_editor TUI no longer exist, so commit messages come straight from the Auditor builder unless operators opt into `$EDITOR` via the existing `--commit-message-editor` flag.
- CommitMessageBuilder now lifts the first non-empty line of the Codex-generated commit summary into the commit subject for both code and narrative commits, so operators see the descriptive `feat:/chore:/docs:` headers they expect; if the summary is blank we still fall back to the legacy `VIZIER …` labels.
- Commit prompts default to a Linux kernel-style template (`type: imperative summary` ≤50 chars, 72-col body, `Signed-off-by` trailers) and can be overridden via `.vizier/COMMIT_PROMPT.md` or `[prompts.commit]` config entries so teams can swap formats without patching code.
- `vizier-core` dropped the unused TUI crate dependency and the editor-specific tool glue (`tools::SENDER`, `edit_content`, `get_editor_tools`, `active_editor_tooling`), leaving only CLI-oriented tools exposed to the backend.
- README and CLI docs now describe a CLI-only workflow so operators aren’t pointed to a non-existent `vizier chat`.
- `vizier review` now exists as a first-class command: it reuses disposable worktrees, runs repo-defined checks (default Cargo check/test or `[review.checks]` commands overrides), runs the merge CI/CD gate (when configured) ahead of critique with auto-remediation disabled, streams Codex’s critique directly to stdout/session logs instead of writing `.vizier/reviews/<slug>.md`, bumps the plan document to `status: review-ready`, and optionally re-enters Codex to apply fixes on the draft branch (`--review-only` skips, `--skip-checks` omits the preflight commands, `-y/--yes` auto-applies). The CLI epilogue reports `critique=terminal` plus the session path, gate status, and commit author notes point back to the session log rather than a Markdown artifact.
- Declining the approve/merge confirmation prompts now exits non-zero (foreground or background preflight) instead of returning success, so cancellation is clearly distinguishable in scripts and CI.
- `vizier list`/`PlanSlugInventory` now surface plan status + `reviewed_at` so operators (and completions) see which draft branches already passed the review checkpoint; `vizier review` keeps that metadata fresh even when checks are skipped.
- README, docs/workflows/draft-approve-merge.md, and AGENTS.md have been updated to cover the extended draft→approve→review→merge choreography so multi-agent runs know where the critique/fix checkpoint lives.
- Assistant operations now route through the Auditor; diffs from assistant-initiated changes are reported with A/M/D/R. Each CLI run writes a structured session log to `.vizier/sessions/<session_id>/session.json` (timestamps, repo state, config snapshot, transcript, outcome) and references that path from commit bodies and Outcome lines; `--no-session` disables the writer when compliance requires it.
- CLI exposes global `--load-session <id>` and `--no-session` flags; `--load-session` reads repo-local `.vizier/sessions/<id>/session.json` artifacts (falling back to the old config-dir format when needed) so operators can resume from in-repo transcripts rather than `$XDG_CONFIG_HOME`.
- Post-action UX lacks a unified Outcome section; README now claims every command emits a one-line Outcome plus structured JSON, but the implementation still relies on ad-hoc lines (e.g., "Save complete; …", snapshot bootstrap summary) and lacks the outcome.v1 schema. Auditor facts are available to drive a canonical epilogue. Outcome component remains a priority (CLI-first with outcome.v1 JSON and stdout epilogue). Canonical thread updated to include acceptance tests and exit-code matrix.
- No built-in agent command: Vizier intentionally lacks a `vizier agent run` flow; operators launch Codex directly and handle branch/PR plumbing outside the CLI.
- AGENTS.md contract/log: Describes the scoped `[agents.default]`/`[agents.<scope>]` configuration (backend, model, reasoning, agent/wire details, and prompt profiles), spells out the precedence order (`CLI flags → [agents.<scope>] → [agents.default] → legacy prompts/keys`), and highlights the single-backend-per-command stance (commands fail fast when the configured backend errors; there is no automatic fallback). It still serves as the short orientation note pointing agents to README, `.vizier/narrative/snapshot.md`, prompts, and the draft→approve→review→merge workflow doc; it is not yet a full decision log.
- Repo-level configs now layer on top of global defaults: when no `--config-file` is provided, Vizier loads `$XDG_CONFIG_HOME`/`~/.config/vizier/config.toml` (or platform equivalent) first, overlays `.vizier/config.toml` (or `.json`) while keeping global defaults for unset keys, logs each source, and only falls back to `VIZIER_CONFIG_FILE` when no config files exist. Docs/examples cover the merged precedence, and tests guard agent/gate/review inheritance.
- `vizier plan` is the read-only way to print the fully resolved configuration (global + repo + CLI overrides) with per-command backend/runtime selection before draft/approve/review/merge; it does not start an Auditor session. Use `--json` for structured output.
- Configuration reference now includes quick-start override scenarios (pin review to Gemini, tighten merge gate retries, disable auto-commit, per-scope prompt swaps) plus a config-vs-CLI override matrix. AGENTS.md points to the reference and calls out the TTY-aware pager (`--pager`/`--no-pager`, `$VIZIER_PAGER`, quiet/`--no-ansi`), and automated coverage checks help output (quiet + `--no-ansi`, non-TTY pager suppression) alongside a regression that bundled progress filters attach to any agent label with a sibling `filter.sh`.
- Documentation config now only honors `include_snapshot`/`include_narrative_docs` (plus the `include_narrative` alias); legacy todo-style keys were dropped now that prompt context ignores `.vizier/todo_*`, and docs point operators to `.vizier/narrative/threads/` instead.
- Narrative GC not yet implemented; policy and levers defined; to be wired into save path and Auditor Outcome.
- Docs prompt templates still ship under `.vizier/docs/prompting/`, but the standalone `vizier docs prompt` command was removed; the upcoming architecture-doc gate (see `.vizier/narrative/threads/architecture_doc_gate_and_commit_history.md`) will wire those templates back into the CLI.
- Legacy side commands (`vizier snapshot …`, `vizier docs prompt …`, and `vizier clean …`) were culled in favor of a lean surface: only `vizier init-snapshot` survives for bootstrap, and narrative hygiene now relies on Default-Action Posture plus the planned GC work tracked in this snapshot.
- Agent backend path now flows through the script runner in `vizier-core/src/agent.rs` (prompts in `agent_prompt.rs`): agent/gemini scopes resolve to a shell command derived from `agent.label` (bundled shims under `examples/agents/`) or an explicit `agent.command`, render stderr progress history, and fail fast when misconfigured; the wire backend is gone, and CLI/model/reasoning overrides now error instead of being silently ignored.
- ScriptRunner now treats a progress filter's stdout as the assistant output so the bundled `examples/agents/codex-filter.sh` (jq-required) can translate Codex JSONL thread/turn/item events into readable progress lines (with usage summaries) while returning the final/fallback agent message on stdout instead of dropping it when a filter is present; Gemini now ships with `examples/agents/gemini/filter.sh`, and the default Gemini runtime pins wrapped output plus that filter so JSONL streams render progress while preserving the final reply (unit-tested in config).
- Gemini agent shim now mirrors Codex shim by printing the first prompt line preview to stderr before invoking the backend, keeping the CLI tests and operator previews aligned across backends.
- Prompt context loading now tolerates missing `.vizier/` by returning empty snapshot/narrative data instead of panicking, so prompts (e.g., review) stay stable even when executed from a nested or misaligned working directory; context now comes exclusively from `.vizier/narrative/` (legacy `.vizier/.snapshot` and `todo_*` files are no longer loaded).
- Rust-side Codex/Gemini adapters were removed in favor of the bundled script shims; `GEMINI.md` now serves as a historical note describing the former adapter shapes and the current shim entrypoints.
- `vizier test-display` session logging now records user/assistant messages via the Auditor API rather than the removed provider config, keeping agent-only configuration in sync with session artifacts.
- `vizier test-display` exercises the configured backend for any scope without touching `.vizier` or Git; it streams progress through the normal display stack, supports prompt/timeout/raw-output overrides plus `--scope` selection, and only writes a session log when `--session` is passed.
- Scoped agent settings now back every assistant command: `[agents.default]` and `[agents.ask|save|draft|approve|review|merge]` tables (plus CLI overrides) resolve to `AgentSettings` structs that carry a single backend and runtime per command. `vizier-cli` threads those settings through `run_save/ask/draft/approve/review/merge`, enforces capability checks (approve/review require an agent-capable backend; merge auto-resolve refuses unsupported backends), updates agent prompt builders with per-scope bounds, and surfaces the resolved backend+scope in session logs and the token-usage suffix (for example, `agent=agent scope=approve`). Docs and integration tests cover the schema and precedence, including `[agents.ask]` overriding the default, CLI `--backend wire` and `fallback_backend` entries being rejected with clear errors, and model/reasoning overrides being removed alongside the wire backend.
- Auditor commit plumbing now calls `FileTracker::sync_vizier_changes` before writing `.vizier` commits and returns early when nothing changed so Codex‑edited snapshot/narrative files get staged without disturbing pre‑existing staged code. Conversation commits were removed; session IDs + paths travel with the `.vizier` and code commits instead, while inline ask flows still commit `.vizier` changes immediately (Pending Commit gate still pending).
- Token usage reporting is now event-driven: each Codex/wire turn emits `[usage] token-usage — prompt=X (+Δ) completion=Y (+Δ) total=Z (+Δ) cached_input=C (+Δ) reasoning_output=R (+Δ)` progress lines that honor verbosity/TTY gating. CLI summaries now append `(tokens: total=T (+Δ) input=I (+Δ, +C cached) output=O (+Δ, reasoning R))`, and quiet mode suppresses the extra chatter; when the backend withholds usage data we fall back to a single `unknown` line with no deltas. Session logs mirror the same total/input/output breakdown so downstream tooling sees `Token usage: total=T (+Δ) input=I (+Δ, +C cached) output=O (+Δ, reasoning R)` with matching data in `.vizier/sessions/<id>/session.json`.
- Architecture doc compliance: no docs/architecture index exists and saves succeed without citing a doc, so there is no auditable linkage from code changes to architecture intent.
- `vizier draft` (Codex-only) provisions a `draft/<slug>` branch from the primary branch tip via a temporary worktree, runs Codex to generate `.vizier/implementation-plans/<slug>.md`, commits the plan on that branch, then cleans up the worktree so the operator’s checkout stays untouched while stdout reports the plan path/branch pairing.
- `vizier list` now exposes the pending-plan backlog as its own subcommand: it enumerates every `draft/<slug>` branch that sits ahead of the detected (or `--target`) branch, prints a header with the pending count (and target when set), and renders each entry as a label/value block with Plan/Branch/Summary (sanitizing quotes/newlines in summaries); the empty state emits a single `Outcome: No pending draft branches` block. The legacy `vizier approve --list` flag is hidden/deprecated and emits a warning that points to the new command.
- Plan workflow commits keep history focused: each draft/approve/review step lands code edits alongside `.vizier/narrative/snapshot.md` and narrative thread updates in a single commit, while plan docs, `.vizier/tmp/*`, and session logs stay scratch artifacts that are filtered out of staging/merge targets.
- `vizier approve` implements the approved plan on the draft branch in a disposable worktree (agent-backed), auto-commits the branch so reviewers can diff against the target, and now streams the backend’s raw stdout/stderr directly to the CLI’s stderr via passthrough mode (token usage recorded as `unknown` when the backend withholds it). Backend failures now emit an explicit `agent backend …` error on stderr before the command aborts so operators/tests can tell the Codex layer failed instead of silently falling back. `vizier review` extends that workflow with a review checkpoint: it spins another worktree, runs the configured checks (defaults to `cargo check --all --all-targets` + `cargo test --all --all-targets` when `Cargo.toml` exists or the `[review.checks]` commands in config), captures the diff summary, streams the backend’s critique to stdout (session logs capture the transcript), marks the plan document `review-ready`, and optionally re-enters the agent to apply fixes using the in-memory critique (prompted unless `--review-only` or `-y/--yes`). `vizier merge` now removes `.vizier/implementation-plans/<slug>.md`, refreshes `.vizier` state, and by default replays the plan branch onto the target, soft-squashes that range into a single implementation commit, then writes a follow-up merge commit (subject `feat: merge plan <slug>`) that embeds the stored plan; in squash mode that merge commit has a single parent (the implementation commit) so the draft branch stays out of the target ancestry, while `--no-squash` keeps the legacy two-parent merge from `draft/<slug>`. When a plan branch contains merge commits, squash mode now preflights the history and requires either `--squash-mainline <parent index>` (or `[merge] squash_mainline`) to select the mainline or `--no-squash` to keep the original graph; ambiguous octopus merges abort early with guidance. The optional CI/CD gate defined under `[merge.cicd_gate]` or `--cicd-script` runs from the repo root while the implementation commit is staged in squash mode (or immediately after the merge commit in legacy mode); success prints the merge summary (deleting the draft branch unless `--keep-branch` is set), while failure streams the script’s stdout/stderr and aborts before deletion/push so operators can inspect the repo. CLI overrides (`--cicd-script PATH`, `--auto-cicd-fix`, `--no-auto-cicd-fix`, `--cicd-retries N`) merge with config, and agent-backed merges can auto-remediate gate failures by applying scoped fixes (amending the implementation commit in squash mode or writing `Fix CI/CD gate failure…` commits in legacy mode) before rerunning the script. Gate checks also run when resuming via `--complete-conflict`. Approve supports `-y/--yes`, `--target`, and `--branch`; Review adds `--review-only`, `--skip-checks`, `-y/--yes`, `--target`, and `--branch`; Merge now supports `-y/--yes`, `--keep-branch`, `--target`, `--branch`, `--note`, `--auto-resolve-conflicts`, `--complete-conflict`, `--cicd-script`, `--auto-cicd-fix`, `--no-auto-cicd-fix`, `--cicd-retries`, and `--[no-]squash`.
- Approve stop condition: `[approve.stop_condition]` (plus `--stop-condition-script`/`--stop-condition-retries`) runs a repo-local script after each approve attempt; a zero exit stops the loop, non-zero triggers another agent run until the default three extra attempts are spent. Each attempt is audited (status/exit/stdout/stderr), epilogues show the script label and attempt counts, and pushes are deferred until a passing run.
- Shell completions: `vizier completions <bash|zsh|fish|powershell|elvish>` prints a dynamic script that wires the hidden `vizier __complete` path to Clap’s completion engine; once sourced, Vizier offers subcommand/flag completion plus `vizier approve`/`vizier merge` positional tab-completion for pending plan slugs via the shared `PlanSlugInventory` helper (scans `.vizier/implementation-plans/*.md` plus `draft/*` branches, filters merged branches, and returns slug/branch/summary metadata for completions, `vizier list`, and docs). README + docs/workflows now call out the command so operators can install it alongside the draft→approve flow.
- Merge conflicts are now resumable: when libgit2 reports conflicts, Vizier materializes the merge index into the working tree, writes a resume token under `.vizier/tmp/merge-conflicts/<slug>.json`, and exits with guidance. Operators can resolve + rerun `vizier merge <slug> --complete-conflict` to reuse the stored commit metadata once the index is clean, or pass `--auto-resolve-conflicts` to let Codex attempt a scoped auto-resolution before falling back to manual cleanup. The completion flag refuses to run when no sentinel exists, when Git isn’t in merge state, or when the operator isn’t on the recorded target branch, keeping history tidy. Sentinel files are deleted automatically once the merge commits.
- Implementation-plan prompting now lives in `vizier-core/src/lib.rs::IMPLEMENTATION_PLAN_PROMPT`, and `vizier-core/src/agent_prompt.rs::build_implementation_plan_prompt` feeds the agent backend the snapshot, active threads, plan slug/branch metadata, and operator spec so the Markdown plan includes front-matter `{plan, branch, status:draft, created_at, spec_source}` plus “Operator Spec” and “Implementation Plan” sections.
- Implementation-plan, review, and merge-conflict prompts are now routed through the agent prompt store: repositories define `[agents.<scope>.prompts.<kind>]` tables in `.vizier/config.toml` that bind a prompt template (inline text or `path`) plus backend/model/reasoning overrides for each command/surface, while `.vizier/IMPLEMENTATION_PLAN_PROMPT.md`, `.vizier/REVIEW_PROMPT.md`, and `.vizier/MERGE_CONFLICT_PROMPT.md` (and legacy `[prompts.*]` entries) remain as fallbacks when no scoped profile is present. Prompt resolution is scoped per command, and every agent call passes its `CommandScope` into the prompt builders so `vizier ask`, `vizier draft`, `vizier review`, and `vizier merge` share the same snapshot-first discipline while tailoring prompts and backends per workflow.
- Implementation-plan backlog trimmed: completed plans (spinner rip-out and the stop-condition rollout) have been removed from `.vizier/implementation-plans/`, leaving `removing-wire.md` as the lone pending plan artifact so operators only see still-relevant work in `vizier list`/plan inventory surfaces.
- Documentation and review prompt text now reference only the snapshot while still embedding narrative docs via `<narrativeDocs>` when configured, matching the new snapshot-first stance.
- Session logs now capture the active prompt scope/kind/origin, and Auditor exposes the repo-relative prompt path (when applicable) alongside the content hash so downstream tooling can tell whether a run used a scoped `[agents.ask.prompts.base]` profile, a `.vizier/*.md` prompt file, or the baked defaults.
- New VCS helpers (`detect_primary_branch`, `create_branch_from`, `add_worktree_for_branch`, `commit_paths_in_repo`, merge helpers, etc.) manage temporary worktrees under `.vizier/tmp-worktrees/` (now gitignored) so `vizier draft` can stage/commit plan files without touching the operator checkout, and enable clean non‑FF merges for approvals.
- Workspace convenience commands deprecated: `vizier cd`/`vizier clean` now error out because the DAG scheduler owns temp worktrees; any future browse/edit workflow must be reintroduced with scheduler-aware semantics.
- `tests/src/lib.rs` exposes standard `#[test]` cases built on an `IntegrationRepo` fixture that clones `test-repo` + `.vizier` into per-test temp dirs, configures Git identity, caches the release `vizier` binary via `OnceLock`, and now holds a global mutex so integration tests serialize instead of racing on temp repo/agent harness setup; non-`IntegrationRepo` tests that spawn external processes (install + shim coverage) now take the same lock to avoid ENOENT flakes under parallel test threads. Coverage spans workspace cd/clean flows (create/reuse, targeted/all clean, missing-branch failure), `vizier save` flows (including glossary pairing and deleted narrative file coverage), approve/merge wiring, conflict auto-resolution, sentinel creation, the `vizier review --review-only --skip-checks` scenario (now `test_review_streams_critique`, which asserts that no `.vizier/reviews` files exist and the critique header appears in stdout while the plan is marked `review-ready`), plus new CI/CD gate tests: `test_merge_cicd_gate_executes_script` (happy path), `test_merge_cicd_gate_failure_blocks_merge` (non-zero script exits block the merge and preserve the draft branch), and `test_merge_cicd_gate_auto_fix_applies_changes` (mock Codex remediation writes the expected fix file and commits the fix attempt). Additional merge-history coverage enforces the `--squash-mainline` guard on plan branches with merge commits (`test_merge_squash_requires_mainline_for_merge_history`, `test_merge_squash_mainline_replays_merge_history`) and confirms `--no-squash` accepts those histories.
- Agent stdbuf buffering test resilience: the stdbuf progress-flush test now races progress events against agent completion with a longer timeout, reducing load-related flakes while still asserting progress arrives before completion.
- `vizier-core/src/vcs.rs` tests use a `TestRepo` fixture plus repo-aware helpers (`stage_in`, `add_and_commit_in`, `push_current_branch_in`, `unstage_in`) instead of mutating the process CWD, so `cargo test -p vizier-core` runs at default parallelism without `--test-threads=1`.
- Build health: `cargo check --all --all-targets`, `cargo test --all --all-targets`, and the repo CI/CD gate script (`./cicd.sh`) pass; the latest rerun on 2026-01-31 was green after clearing leftover merge-conflict markers in job/test surfaces and reconciling job metadata handling, while the 2026-01-30 merge gate failure that flagged ask/background-related tests remains a non-reproducible flake to monitor.
- CI gate repair: removed stray merge-conflict markers in `install.sh`/`tests/src/lib.rs`, restored job-record test helpers, and cleared `.vizier/jobs` in the integration harness so job list tests run against only their fixtures.
- CI gate repair follow-up: removed leftover merge-conflict markers in `tests/src/lib.rs`, `vizier-cli/src/main.rs`, and `vizier-cli/src/jobs.rs`, and reconciled job-record helpers so queue/worktree metadata can coexist in job listings and cleanup.
- Install script hygiene: `install.sh` no longer contains merge-conflict detritus, so dry-run staging and install/uninstall tests exercise the intended staged-copy flow.
- CLI linting maintenance: `vizier-cli/src/actions.rs`, `vizier-cli/src/jobs.rs`, `vizier-cli/src/main.rs`, and `vizier-cli/src/plan.rs` were tidied for current Rust idioms and lint guidance (error propagation, iterator usage, temp-file handling); the global-flag parsing helper now uses a collapsed `if let` to satisfy clippy with no intended changes to CLI flags, outcomes, or workflow behavior.
- README.md documents `vizier draft`, `vizier list` (standalone pending-plan backlog), `vizier approve` (implementation on the draft branch), and `vizier merge` (default two-commit squash: implementation commit plus a single-parent `feat: merge plan <slug>` commit that embeds the stored plan, with `--no-squash` retaining the draft branch as a second parent) with accurate flags; copy updated to describe the CI/CD gate (`[merge.cicd_gate]`, `--cicd-script`, `--auto-cicd-fix`, `--no-auto-cicd-fix`, `--cicd-retries`), the `--squash-mainline` requirement when squashing plan histories that include merge commits, and the background workflow (`--background` flag, job artifacts, and `vizier jobs` surface). Dedicated DRAFT.md/APPROVE.md are still absent. [Cross: todo_README_add_approve_command.md]
- docs/workflows/draft-approve-merge.md now walks operators through the `vizier draft → vizier approve → vizier merge` choreography, explicitly calling out `vizier list` as the way to inspect outstanding plan branches, and covers prerequisites, Git effects, conflict sentinels, walkthrough, FAQ, compliance tie-ins, the CI/CD gate (config, CLI overrides, auto-remediation, failure recovery table), and the `--squash-mainline` requirement when squashing plan histories that carry merge commits.
- Global `--no-commit` flag (+ `[workflow] no_commit_default`) lets operators hold `.vizier` and plan-branch edits for manual review across ask/save/draft/approve/review. When active, Vizier skips the auto-commit/push, logs that changes are pending, and preserves the disposable worktree for inspection; `vizier merge` still requires auto-commit because merge commits and CI/CD gates depend on finalized history. README and docs call out the new workflow along with the config lever.
- Multi-agent workflows are ad-hoc: there is no structured runbook that walks operators through “discuss → snapshot sign-off → architecture doc draft → implement → code sign-off → save,” so intent can drift between agents and VCS gates.

Acceptance checkpoints (selected)
- Stdout/stderr contract: Non‑TTY emits no ANSI; stdout carries final results; stderr stays limited to errors/warnings per verbosity. Flags -q/-v/-vv and --no-ansi implemented; spinner removed and progress is always line-based under verbosity control. outcome.v1 JSON not yet implemented; standardize across commands. [Active]
- Mode split: `--mode protocol` produces only structured JSON/NDJSON on stdout (no human prose), no ANSI in any environment, deterministic event ordering, and categorized exit codes. Chat mode remains default with human epilogue and optional `--json`/`--json-stream`. Closed-stdin never blocks. [Active]
- Pending Commit gate guards conversation changes with confirm_destructive=true and auto_commit=false.
- Conversation commits only touch .vizier; preserve pre-existing staged changes exactly (A/M/D/R).
- Non-interactive CLI requires explicit consent; never opens editor.
- Session JSON logging: Assistant operations persist structured session records under repo-local `.vizier/sessions/<id>/session.json` (transcript, repo state, config snapshot, prompt hash, model info, outcome summary); CLI epilogues and commits surface the session path, with schema validation, richer resume UX, gate-aware checkpoints, and redaction controls treated as follow-up work. [Active]
- Outcome summaries: After each operation, users see a compact summary matching Auditor/VCS facts; assistant final mirrors it. For CLI actions, the Auditor-backed A/M/D/R must be reflected in both human epilogue and outcome.v1 JSON. Deterministic final Outcome emission. [CLI-first]
- Narrative GC on save: During `vizier save`, duplicate/superseded/empty/orphaned narrative entries are deleted or staged for deletion per config; Outcome reports deletions with reasons; dry-run supported; protected items skipped. [Active]
- Architecture doc gate: Saves refuse to finalize without a cited architecture doc; outcomes and commits include the referenced path, and multi-agent runs share the same doc reference. [Planned]

Next moves
1) Stdout/stderr contract + verbosity: complete the contract by standardizing a stable stdout Outcome across commands and wiring an outcome.v1 JSON while keeping the new spinner-free, line-based history disciplined. [Active]
2) Outcome component: implement outcome.v1 schema; include audited A/M/D/R, gate state, and (when applicable) {todo, branch, commit_count, pr_url}. Print to stdout on success; `--json`/stream variants. Ensure it fires after every ask/save. [Active]
3) Mode split wiring: Add `--mode protocol` to CLI, thread through to core display/observer; enforce protocol-mode IO rules, exit codes, and metadata {mode:"protocol"}. Ensure closed-stdin safe behavior. [Active]
4) Ask gate parity: Place assistant-initiated edits (ask flows) behind a Pending Commit gate instead of immediate commit; surface via Outcome/JSON. Preserve pre-existing staged work. [Active]
5) Narrative GC wiring: Add product‑level GC behavior into the save path with config/flags; surface detailed Outcome facts and integrate with Pending Commit gate where enabled. [Active]
6) Session logging follow-ups: now that repo-local `.vizier/sessions/<id>/session.json` artifacts ship with each run, add resume/diff tooling, redaction levers, and schema validation so downstream agents can trust the record. [Active]
7) Architecture doc enforcement + history: Add compliance gates that require architecture docs for every code change, store doc references alongside commits, and surface discrepancies via Auditor/Outcome before merge. [New]
8) Agent workflow orchestration: Give operators a first-class workflow that sequences snapshot approval, architecture doc drafting, implementation, code sign-off, and final `vizier save`, with Auditor/Outcome breadcrumbs for each checkpoint. [New]
9) Draft approval plumbing: SHIPPED. `vizier approve` applies the plan on the draft branch; `vizier merge` now defaults to the squash flow (single implementation commit plus a follow-up `feat: merge plan <slug>` commit embedding the stored plan, with the merge commit referencing only the implementation commit so `draft/<slug>` drops out of ancestry). `[merge] squash`/`--no-squash` restores the legacy merge that keeps `draft/<slug>` as a second parent. Plan branches with merge commits must supply `--squash-mainline <parent>` (or `[merge] squash_mainline`) in squash mode or fall back to `--no-squash`, with ambiguous octopus merges aborted early. Follow‑ups: standardize Outcome epilogue/JSON for approve/list/merge, add protocol‑mode parity, surface session paths, and surface squash/gate metadata in Outcome/session logs. [Active]
10) Git hygiene + commit practices: Define and document commit-boundary guidelines and commit message conventions for Vizier-driven workflows (code vs `.vizier` vs narrative), ensure CommitMessageBuilder and CLI flows apply them consistently, and surface them in docs/Outcome so human and agent commits keep history clean and auditable. [New]
11) Manual smoke coverage: run a lightweight human smoke of core CLI flows (ask/save/draft/list/approve/review/merge plus quiet/no-ansi variants), capture session log references, and record regressions as narrative follow-ups so releases do not rely solely on automated checks. [New; see: .vizier/narrative/threads/manual_smoke_cli.md]
12) Workspace/worktree management: define the scheduler-era replacement for `vizier cd/clean` (attach/detach, inventory surfacing, gate alignment) so operators can browse WIP drafts without touching their base checkout. [Active]

Cross-links
- Output contract + Mode split ↔ Outcome summaries: the same event stream feeds human epilogues, protocol JSON, and CLI results without ANSI leakage.
- DAP ↔ Outcome ↔ Narrative GC: default-action edits update .vizier, GC keeps the garden tidy, and the Outcome line reports those edits.
- Commit isolation + gates ↔ Architecture doc compliance: pending commits and save gates must cite the architecture doc reference and surface it in outcomes/commits.
- Session logging ↔ Auditor facts: assistant operations persist audited facts to session.json, and the Outcome epilogue points to the artifact for downstream tooling.
- Agent workflows ↔ Commit/Doc gates: the same checkpoints that gate architecture docs and pending commits must be surfaced as workflow steps so multi-agent runs stay aligned and auditable.
- Git hygiene + commit practices ↔ Commit isolation/Architecture-doc/Outcome: commit boundaries and commit messaging conventions carry session IDs, gate status, and doc references so repositories get a consistent, reviewable history for both human and agent commits.

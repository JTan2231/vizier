Running Snapshot — updated

Narrative theme
- Reduce operator friction: conversational intent is authorization to evolve the project. The assistant maintains a living snapshot and task list by default; users can explicitly opt out per turn.
- Editorial housekeeping: Narrative artifacts now live under `.vizier/narrative/` (snapshot, glossary, and thread docs); legacy TODO files were migrated and the save path should enforce garbage-collection to keep a single canonical thread per tension.
- Direct narrative edits: Narrative upkeep is done by editing `.vizier/narrative/` files in-repo (no Vizier CLI invocations), staying within repo boundaries (no parent-directory access) and avoiding network access unless explicitly authorized, while keeping snapshot + glossary in lockstep as the canonical story surfaces.
- Operational bounds: All agent work stays within the repo boundary and avoids parent-directory access or network use unless the user explicitly authorizes it; this applies to code, docs, and narrative work alike.
- Explicit-instruction guardrail: AGENTS.md requires explicit instruction before editing `.vizier/narrative/`; until precedence is codified, narrative upkeep is treated as opt-in per explicit instruction even when DAP would otherwise apply, and that authorization covers snapshot/glossary plus supporting thread docs as needed; current task format explicitly calls out "Update the snapshot, glossary, and supporting narrative docs as needed" (including when wrapped inside `<task><instruction>...</instruction></task>`) to satisfy the guardrail, and its absence means the turn is a narrative no-op.
- Task-envelope execution: Narrative-maintenance turns now package explicit update authorization together with inline snapshot/thread context, so agents should execute editorial updates in the first response against the on-disk canonical `.vizier/narrative/*` files and return only a commit-style summary, unless the user explicitly says not to update.
- Codex-integrated posture: Codex now handles the heavy agent work directly, so Vizier trims internal orchestration threads and focuses on snapshot accuracy plus CLI guardrails.
- Pluggable agent posture: Vizier must treat “agent” as a swappable backend (Codex today, Claude and others next) with a stable interface for capabilities, prompts, and telemetry, so plan/approve/review flows don’t have to be rewritten each time a new CLI agent is introduced.
- Config-first posture: Treat configuration as a first-class surface above Git and external agents; new features should ship with repo/CLI knobs and sensible defaults so operators are not forced into an overly opinionated workflow but still get high utility out of the box.
- Reduction posture: Workflow orchestration is converging on a configurable template surface (Node/Edge/Template/PolicySnapshot) so built-in wrappers keep their UX while reducing command-local control loops and making resume/gate behavior auditable from artifacts.
- Lean backlog: Threads that do not protect Codex-era workflows were culled; the remaining arcs prioritize IO contracts, auditability, and documentation gates.
- Bureaucratic enforcement: Treat Vizier as the compliance enforcer for large-organization processes (architecture docs per change, auditable histories, PR-ready artifacts).
- Change discipline: AGENTS.md explicitly reiterates that code changes must update tests/docs and pass the repo’s `./cicd.sh` checks before they’re treated as done.
- Story-editor discipline: Snapshot updates are read-before-write, diff-like merges that convert conversations into concrete plot points (not parallel “investigate X” tasks), cross-link to existing threads, stay evidence-backed, and remain product-level by default (pointer anchors when useful; implementation detail only when required by explicit request, safety/correctness, or an already-chosen blocking technical constraint). Each slice should read like a Chekhov cue by pairing a specific tension with the concrete behavior change and acceptance signal it implies. Keep the trade space open when implementation is not forced, and avoid prescribing concrete data structures, library choices, or file-by-file rewrites in default snapshot entries. Glossary updates stay in lockstep; see `vizier-core/src/lib.rs::SYSTEM_PROMPT_BASE` for the abstraction rules.
- Snapshot framing: The snapshot is a single authoritative frame at time T with two slices—Code state (user-visible behavior and constraints) and Narrative state (active themes, tensions, and open threads). Updates should preserve that split and stay product-level unless safety/compliance or explicit request demands detail.
- Context recovery: When users say they’re forgetting context, respond by surfacing the relevant snapshot slice and active threads to re-anchor the conversation before proceeding.
- Orientation discipline: Agents are expected to reread `.vizier/narrative/snapshot.md`, README, and the prompt scaffolding (especially `docs/user/prompt-config-matrix.md` as the canonical map of prompt scopes/kinds/levers and `docs/user/config-reference.md` as the full configuration catalogue with override examples), and to scan the current implementation for architectural/styling patterns before planning so every run starts grounded in the current story; AGENTS.md and `vizier plan` (echoes resolved settings) provide the fast orientation path.
- Documentation path coherence: User-facing references are currently split between AGENTS.md/README root aliases (`docs/config-reference.md`, `docs/prompt-config-matrix.md`) and on-disk docs under `docs/user/*`; until aliases or links are reconciled, treat `docs/user/config-reference.md`, `docs/user/prompt-config-matrix.md`, and `docs/user/workflows/draft-approve-merge.md` as the canonical paths.
- Human-only docs guardrail: AGENTS.md reiterates that README.md and AGENTS.md remain human-authored, so agents treat them as read-only orientation surfaces unless a human explicitly directs otherwise.
- Snapshot-first prompting: Documentation/review prompt text now speaks only about keeping the snapshot current (no narrative-doc output), while narrative docs remain optional context via `<narrativeDocs>` when enabled and the base prompt in `vizier-core/src/lib.rs` reflects that scope.
- Initialization contract: `vizier init` is now the canonical, idempotent repo bootstrap command; initialization is defined by durable marker files (`.vizier/narrative/snapshot.md` + `.vizier/narrative/glossary.md`) plus required `.gitignore` coverage for ephemeral Vizier runtime paths, and `vizier init --check` validates the contract without mutating the repo.
- Commit-style epilogues: Assistant-facing responses collapse to a single, commit-message-like summary of what changed (not raw `snapshotDelta` text); detailed snapshot/narrative deltas and outcome JSON stay machine-oriented inside `.vizier` rather than being printed verbatim.

Active threads
- Stdout/stderr contract + verbosity: ACTIVE (partially shipped). CLI now supports -q/-v/-vv and --no-ansi, spinner rendering has been ripped out entirely, and vizier-core::display only emits line-based history that honors verbosity/TTY without any `--progress` flag. Codex JSON events end up as `[codex] phase — message` lines that respect quiet/verbosity so every ask/save/approve flow leaves a readable trace. The remaining work is to standardize a stable stdout Outcome line/JSON (outcome.v1) across commands and ensure stderr stays limited to errors/progress. [Cross: Outcome summaries; see: .vizier/narrative/threads/stdout_stderr_contract_and_verbosity.md]
- Mode split: Human-first CLI vs Protocol Mode v1: ACTIVE. Default CLI output stays human-first with readable epilogues; Protocol mode is machine-first with structured JSON/NDJSON on stdout, no ANSI, deterministic ordering, and categorized exit codes. Planned toggle `--mode protocol` (not yet implemented); JSON stream will share the same event contract as the human-mode CLI output. [Cross: Stdout/stderr, Outcome summaries]
- Commit isolation + gates: ACTIVE. Conversation- and agent-sourced changes are staged behind a Pending Commit gate; assistant flows must funnel through the Auditor before commits land. [Depends on: Outcome summaries, Session logging]
- Git hygiene + commit practices: ACTIVE. Vizier’s commit flows (for code, `.vizier`, and narrative changes) emphasize gating and session logging but lack a clear, documented story for commit boundaries, message style, and how agent-authored commits should look alongside human history; we need consistent practices for what gets committed when and how commit subjects/bodies and trailers communicate intent, sessions, and any required gates. Current plan artifacts continue to drift: this worktree has `.vizier/implementation-plans/refactor.md` + `removing-wire.md`, while local draft branches include `draft/after`, `draft/approve`, `draft/develop`, and `draft/watch` (with `build/patch-740958c5f8bf` also present and outside the draft-plan mapping), and `.vizier/implementation-plans/watch.md` is currently tracked as deleted in the working tree. This reinforces the need for explicit plan-doc/branch hygiene in this thread. [Cross: Commit isolation + gates, Architecture doc gate + compliance; see: .vizier/narrative/threads/git_hygiene_and_commit_practices.md]
- Default-Action Posture (DAP): ACTIVE. By default, snapshot and narrative docs update on every user input unless the user opts out per-turn (e.g., prefixing “no-op:” or “discuss-only:” or explicitly asking not to update). AGENTS.md now states narrative edits require explicit instruction, so we need to reconcile the opt-in guardrail with DAP’s default-action promise and document precedence. Stopgap: treat explicit instruction as a prerequisite for narrative edits until precedence is codified, and treat task envelopes that include the explicit update instruction as immediately authorized editorial turns; once authorized, only an explicit no-update signal suppresses first-response narrative edits, and authorized edits should close a concrete tension with behavior-level acceptance framing rather than implementation prescriptions. CLI surfaces a one-line Outcome whenever DAP acts. [Cross: Outcome summaries; see: .vizier/narrative/threads/default_action_posture.md]
- Outcome summaries: ACTIVE. A unified human epilogue and outcome.v1 JSON must reflect Auditor A/M/D/R facts and gate state after every action. [Depends on: Auditor]
- Architecture doc gate + compliance: ACTIVE. Every code change needs an attached architecture doc logged in commit history; Vizier enforces creation, storage, and linkage before merges or saves. [Depends on: Outcome summaries, Commit isolation/gates]
- Session logging to filesystem: ACTIVE (MVP shipped). CLI now writes repo-local `.vizier/sessions/<id>/session.json` artifacts (transcripts, repo state, config snapshot, outcome) and surfaces the path in outcomes/commits; each outcome now carries a `token_usage` totals+delta block so auditors can reconcile the CLI epilogue. `vizier test-display --session` now records the agent context so session logs capture the resolved scope. Next steps are richer resume UX, redaction levers, and gate-aware checkpoints. [Depends on: Auditor facts, Outcome]
- Narrative Garbage-Collection on save: ACTIVE. Vizier should aggressively remove duplicate, superseded, empty, and orphaned narrative entries during `vizier save` and after material thread merges, with safety levers and clear Outcome reporting. [Depends on: Config, Auditor, VCS, file tracking, Snapshot Threads]
- Agent workflow orchestration: ACTIVE. Operators want Vizier to act as the conductor for multi-agent runs (snapshot wording sign-off → architecture doc draft → implementation → review/fix sign-off → `vizier save`), so the CLI/Auditor stack must expose those checkpoints and keep the VCS gates tight. `vizier review` now provides the dedicated critique/fix checkpoint with configurable check commands, review artifacts, and plan-status metadata, and the implementation-plan/review/merge prompts are now repo-configurable via the prompt store, but we still need the broader conductor story (architecture-doc gate, pending-commit orchestration, workflow UI) plus a tamer flag surface for the rest of the plan workflow, and a codified CI/CD gate whose checks must pass before an agent-backed command is treated as successful. The merge step now wires that gate via `[merge.cicd_gate]` plus per-run overrides (`--cicd-script`, `--auto-cicd-fix`, `--no-auto-cicd-fix`, `--cicd-retries`) so merges cannot complete until the repo-defined script exits 0 (with Codex remediation when enabled), but we still need gate metadata flowing into Outcome summaries/session logs and reusable gate profiles for ask/save/draft/approve/review. [Cross: Commit isolation, Architecture doc gate, Outcome summaries; see: .vizier/narrative/threads/draft_approve_merge_config_surface.md, .vizier/narrative/threads/agent_command_cicd_gate.md]
- Workspace/worktree management for plan branches: ACTIVE (reassessment). The DAG scheduler now owns temp worktrees, and `vizier cd`/`vizier clean` are deprecated + error out, so we need a scheduler-aware way to browse/edit draft branches (attach/detach, inventory surfacing) without reviving the old workspace manifests. [Cross: Agent workflow orchestration, draft→approve→merge config]
- Agent backend abstraction + pluggable CLI agents: ACTIVE. Vizier exposes scoped `[agents.default]`/`[agents.<command>]` config tables plus CLI overrides so each command (`ask`, `save`, `draft`, `approve`, `review`, `merge`) resolves its own `AgentSettings` (selector and runtime bounds) mapped to a runner/display pair. Only agent/gemini stacks remain: scopes now pick a bundled shim via a canonical `agent = "codex"|"gemini"|<custom>` selector (with optional `[agents.<scope>.agent].command` overrides) while CLI users drive the same choice via `--agent` instead of the deprecated `--backend`. Wire/model/reasoning/fallback keys still hard-error when present. Next steps are to surface capability discovery and per-selector options (so non-Codex agents can advertise which flows they support), finish backend-neutral progress/telemetry adapters, and allow fully pluggable CLI agents without rewriting the draft/approve/review workflow. Prompt templates (base/commit plus implementation-plan/review/merge-conflict) already flow through the config store so selector swaps inherit repo-specific instructions. [Cross: Agent workflow orchestration, Agent backend path in Code state; see: .vizier/narrative/threads/pluggable_agent_backends.md]
- Configuration posture + defaults: ACTIVE. Configuration is treated as a first-class surface above Git and external agents; new features and threads should expose their levers through a coherent config story with repo/CLI knobs and sensible defaults, so operators get a high-utility but non-imposed experience while still satisfying governance and workflow constraints. The agent selector rewrite moved `backend`/`label` into a single `agent = "<shim>"` knob (plus CLI `--agent`) and refreshed `example-config.toml`, the config reference, and the plan workflow doc accordingly; remaining doc-path drift (`docs/*.md` aliases in AGENTS/README vs `docs/user/*` on disk) is tracked under this thread, including keeping shorthand references synchronized until the docs tree is flattened. [Cross: Agent workflow orchestration, Agent backend abstraction + pluggable CLI agents, Architecture doc gate + compliance, Stdout/stderr contract + verbosity; see: .vizier/narrative/threads/configuration_posture_and_defaults.md]
- Repository initialization contract (`vizier init`): ACTIVE (v1 shipped). `vizier init`/`vizier init --check` now provide an explicit bootstrap contract (durable marker files + required `.gitignore` runtime rules), idempotent scaffolding, and a non-mutating check path that no longer creates `.vizier/sessions`/`.vizier/jobs` during pre-dispatch setup. Remaining follow-up is README/AGENTS human-authored wording alignment so orientation copy reflects `vizier init` rather than legacy bootstrap references. [Cross: Snapshot-first prompting, Narrative storage, docs path coherence; see: .vizier/narrative/threads/snapshot_bootstrap_and_init_snapshot.md]
- Workflow-template reduction surface: ACTIVE (phase 1-5 progress shipped). Kernel now defines a versioned workflow-template contract and stable policy snapshot hashing, command dispatch/build paths compile template scope+node metadata into scheduler/job artifacts, and build resume now rejects policy drift with node/edge/policy/artifact diagnostics instead of opaque mismatches. Compile-time capability-contract validation now rejects invalid approve/review/merge loop wiring, gate cardinality, and schedulable arg-shape violations before queueing, wrapper/build scheduling prevalidates full node sets so invalid templates fail pre-queue without partial graph creation, and review runtime now resolves its primary node semantically (capability-first) instead of hard-coding `review_critique`. `vizier run <alias>` now executes repo-defined composed templates through the same DAG scheduler path, including import/link expansion for file-backed templates and `[commands.<alias>]` plus repo fallback alias resolution. Remaining work is to finish migrating the remaining command-local execution loops (approve/review/merge behavior) behind explicit template nodes and then decide whether top-level `vizier <alias>` sugar should wrap `run` without shadowing built-ins. [Cross: Agent workflow orchestration, Configuration posture + defaults, Session logging; see: .vizier/narrative/threads/workflow_template_reduction_surface.md]
- Snapshot bootstrap ergonomics: ACTIVE (follow-up). With `vizier init` now canonical, injecting a useful first snapshot into mature projects is still awkward; operators need a "start where you are" path with lightweight, present-focused notes instead of full retrospectives. [Cross: Snapshot-first prompting, Narrative storage, README bootstrap examples; see: .vizier/narrative/threads/snapshot_bootstrap_and_init_snapshot.md]

Code state (behaviors that matter)
- Agent selector unification: `example-config.toml`, `docs/user/config-reference.md`, and the workflow doc now show the canonical `agent = "<selector>"` key (default `codex`) plus optional `[agents.<scope>.agent]` command overrides, replacing the older `backend` + `agent.label` duo. CLI selector overrides now flow through `--agent` (while `--backend` remains deprecated and warns before translation), and runtime command/label one-offs are file-backed via config (`[agents.commands.<alias>.agent]` + `--config-file`) instead of ad-hoc global flags. Tests cover config layering, plan JSON output (`agent` + `backend` fields), and buffered runner behavior under the new settings. The sample config + plan recap now explicitly warn that the root `agent` scalar and `[agent]` table are mutually exclusive, so custom-runner instructions no longer lead to invalid TOML.
- Config parser cleanup: `vizier-core/src/config.rs` now matches only the concrete `BackendKind` variants when translating deprecated `backend` keys and inspects the root `agent` entry via `as_str()`/`parse_agent_runtime_override`, eliminating the unreachable-pattern warnings that `cargo check` used to emit for both paths.
- Display/verbosity: vizier-cli wires -q/-v/-vv and --no-ansi into vizier-core::display, spinner rendering has been removed entirely, and progress is now always line-based with Info/Debug lines gated purely by verbosity (quiet fully suppresses history). Non‑TTY never sees ANSI artifacts.
- Help output now uses a TTY-aware pager with auto-TTY behavior plus `$VIZIER_PAGER`; `--no-ansi` strips ANSI from help text, and quiet/non-TTY print directly. `--pager` was removed from the operator-facing surface, while hidden `--no-pager` remains an internal child-process control.
- Explicit init command: `vizier init` is now a first-class CLI surface with `vizier init --check`; mutate mode creates missing durable markers and appends missing runtime ignore rules (`.vizier/tmp/`, `.vizier/tmp-worktrees/`, `.vizier/jobs/`, `.vizier/sessions/`) without overwriting existing marker content or duplicating ignore entries, while check mode prints missing items and exits non-zero without filesystem mutations.
- Documentation path drift: `docs/user/config-reference.md`, `docs/user/prompt-config-matrix.md`, and `docs/user/workflows/draft-approve-merge.md` exist on disk, but AGENTS.md/README still reference root aliases for the config/prompt docs (`docs/config-reference.md`, `docs/prompt-config-matrix.md`) while workflow guidance already points to `docs/user/workflows/draft-approve-merge.md`; orientation guidance remains split until links or aliases are normalized.
- Narrative storage: `.vizier/narrative/snapshot.md` is the canonical snapshot, `.vizier/narrative/glossary.md` is the canonical glossary, and thread docs live under `.vizier/narrative/threads/`; legacy `.vizier/.snapshot` and `.vizier/todo_*` files were removed during migration.
- Narrative pairing: Agent prompts treat snapshot+glossary updates as a coupled surface; narrative upkeep now expects the glossary to be updated whenever the snapshot changes (not just during `vizier save`), and `vizier save` still fails when the snapshot changes but the glossary does not, keeping narrative edits consistent across workflows.
- Codex progress history: Instead of an overwriting spinner, every Codex event now renders to stderr as `[codex] <phase> — <message>` with percentage, status, and any detail/path gleaned from the event payload (`phase`, `label`, `message`, `detail`, `data.path`, `progress`, `status`, `timestamp`). Quiet mode suppresses the stream, while `-v/-vv` add timestamps and the raw JSON for auditing. `vizier approve` and Codex-powered conflict auto-resolution now share the same renderer instead of streaming raw stdout.
- stdout usage remains inconsistent; some commands (e.g., save, init, clean) emit ad‑hoc outcome lines, but there is no standardized outcome.v1 JSON or unified Outcome component yet.
- No explicit mode switch exists; protocol-style behavior is not yet implemented. Machine-readable output is command-local (`vizier plan --json`, `--format json` on JSON-capable list/jobs surfaces), but there is still no unified outcome.v1 schema or protocol-mode contract.
- Scheduler-backed execution + job records: Assistant commands now always enqueue DAG jobs, and `--follow` attaches to job logs. Legacy global `--background`/`--no-background` and global `--json` were removed with migration guidance, so machine-readable output is command-local (`jobs ... --format json`, `plan --json`) instead of global. Job records now carry `child_args` plus `schedule` metadata (`after` edges, dependencies, locks, artifacts, pinned head, wait reason, waited_on), and statuses include queued/waiting_on_deps/waiting_on_locks/blocked_by_dependency to keep wait states observable. Build execute now compiles phase schedules from `template.build_execute` nodes, so approve/review/merge phase jobs carry explicit `schedule.after` links to predecessor phase jobs and template-derived gate labels, while materialize keeps empty `after` unless operator-provided `--after` dependencies apply. `vizier jobs schedule` now supports an interactive watch mode (`--watch`, plus `--top` and `--interval-ms`) that renders a live summary dashboard with running-job latest log line, while hard-rejecting non-TTY/no-ANSI contexts and `--format dag|json` combinations to preserve script-safe behavior on non-watch paths. Launching a detached job still prints the multi-line `Outcome: Background job started` block on stdout (stopgap until the stdout/stderr Outcome contract is standardized). Background job finalization flushes stdout/stderr before marking jobs complete so `vizier jobs tail --follow` and log readers capture the final assistant output. Job metadata (scope/target/plan, agent/backend/config snapshot, agent exit codes, session/outcome paths) still lives under `.vizier/jobs/<id>/{job.json,outcome.json,stdout.log,stderr.log}`, and `vizier jobs` continues to offer `status`, `tail`, `attach`, `cancel`, and `gc` actions with labeled log streaming; cancellation sends SIGTERM and marks jobs cancelled (exit 143) while GC prunes finished jobs past the retention window.
- Workflow-template contract + compiler path: `vizier-kernel/src/workflow_template.rs` now defines the canonical template surface (`WorkflowTemplate`, nodes/edges/gates/retry, `WorkflowPolicySnapshot`) plus deterministic hashing and compile helpers. `vizier-cli/src/workflow_templates.rs` resolves per-command template refs (including `id@version` / `.vN` forms) and compiles node metadata for scheduler submissions so wrappers keep the same UX while sharing one reduction model.
- Compile-time capability contracts: `vizier-kernel/src/workflow_template.rs::validate_workflow_capability_contracts` now validates schedulable capability dependencies (approve stop-condition loops, merge conflict/CI-CD remediation loops, review gate cardinality, custom-command fallback shape, and patch/draft/materialize arg contracts) at template-compile time. `vizier-cli/src/cli/dispatch.rs` and `vizier-cli/src/actions/build.rs` now precompile full wrapper/build node sets before enqueueing jobs, so invalid templates fail before any job records are created.
- Review semantic-primary parity: `vizier-cli/src/actions/review.rs` now resolves the review node through `resolve_primary_template_node_id` instead of assuming `review_critique`, so capability-valid custom review templates with renamed node IDs pass both scheduling and runtime gate extraction.
- Template-config + plan visibility: Config now includes wrapper template mappings with built-in defaults in `vizier-kernel/src/config/defaults.rs`, while `[commands]` remains the primary alias-to-template selector map (including custom aliases such as `develop`). Parser/layering honor overrides, and `vizier plan` now reports resolved template selectors in both text and JSON output (including `/commands/develop/template_selector` when configured).
- Composed file templates + alias resolution: File-backed workflow templates can now declare `imports` + `links` so repos compose stage templates into one DAG with compile-time cycle/collision validation and deterministic prefixing. `vizier run <alias>` resolves `[commands.<alias>]` selectors first, then repo fallback files (`.vizier/<alias>.toml|json`, `.vizier/workflow/<alias>.toml|json`) when unmapped.
- Workflow observability metadata: Job records now carry workflow compile facts (`workflow_template_id`, `workflow_template_version`, `workflow_node_id`, `workflow_policy_snapshot_hash`, `workflow_gates`), `vizier jobs` can render/filter those fields, and background config snapshots include workflow template settings so detached runs remain auditable.
- Build resume policy snapshots: Build execution state now stores template ref + policy snapshot hash/details in `execution.json`; resume drift errors are categorized as node/edge/policy/artifact mismatches, and integration coverage asserts these categories plus stage-barrier drift handling.
- Ask/save scheduling: ask/save run in disposable worktrees under a pinned head and serialized repo lock; successful runs cherry-pick a single commit back onto the target branch when the pinned head still matches and the worktree is clean.
- Merge queue removal: merge serialization now comes from scheduler locks; merge-queue config/state files are gone.
- Interactive chat command removed; the former alt-screen UI and its supporting modules (`vizier-core/src/chat.rs`, `vizier-core/src/editor.rs`) were deleted, so all work happens through CLI commands (ask/draft/save/approve/review/merge) with no diff-preview surface.
- Commit confirmation detours were removed end-to-end: the `--require-confirmation` flag, chat/editor prompts, and run_editor TUI no longer exist, so commit messages come straight from the Auditor builder unless operators opt into `$EDITOR` via the existing `--commit-message-editor` flag.
- CommitMessageBuilder now lifts the first non-empty line of the Codex-generated commit summary into the commit subject for both code and narrative commits, so operators see the descriptive `feat:/chore:/docs:` headers they expect; if the summary is blank we still fall back to the legacy `VIZIER …` labels.
- Commit prompts default to a Linux kernel-style template (`type: imperative summary` ≤50 chars, 72-col body, `Signed-off-by` trailers) and can be overridden via `.vizier/COMMIT_PROMPT.md` or `[prompts.commit]` config entries so teams can swap formats without patching code.
- `vizier-core` dropped the unused TUI crate dependency and the editor-specific tool glue (`tools::SENDER`, `edit_content`, `get_editor_tools`, `active_editor_tooling`), leaving only CLI-oriented tools exposed to the backend.
- README and CLI docs now describe a CLI-only workflow so operators aren’t pointed to a non-existent `vizier chat`.
- `vizier review` now exists as a first-class command: it reuses disposable worktrees, runs repo-defined checks (default Cargo check/test or `[review.checks]` commands overrides), runs the merge CI/CD gate (when configured) ahead of critique with auto-remediation disabled, streams Codex’s critique directly to stdout/session logs instead of writing `.vizier/reviews/<slug>.md`, bumps the plan document to `status: review-ready`, and optionally re-enters Codex to apply fixes on the draft branch (`--review-only` skips, `--skip-checks` omits the preflight commands, `-y/--yes` auto-applies). The CLI epilogue reports `critique=terminal` plus the session path, gate status, and commit author notes point back to the session log rather than a Markdown artifact.
- Declining the approve/merge confirmation prompts now exits non-zero (foreground or background preflight) instead of returning success, so cancellation is clearly distinguishable in scripts and CI.
- `vizier list`/`PlanSlugInventory` now surface plan status + `reviewed_at` so operators (and completions) see which draft branches already passed the review checkpoint; `vizier review` keeps that metadata fresh even when checks are skipped.
- README, docs/user/workflows/draft-approve-merge.md, and AGENTS.md have been updated to cover the extended draft→approve→review→merge choreography so multi-agent runs know where the critique/fix checkpoint lives.
- Assistant operations now route through the Auditor; diffs from assistant-initiated changes are reported with A/M/D/R. Each CLI run writes a structured session log to `.vizier/sessions/<session_id>/session.json` (timestamps, repo state, config snapshot, transcript, outcome) and references that path from commit bodies and Outcome lines; `--no-session` disables the writer when compliance requires it.
- CLI exposes global `--load-session <id>` and `--no-session` flags; `--load-session` reads repo-local `.vizier/sessions/<id>/session.json` artifacts (falling back to the old config-dir format when needed) so operators can resume from in-repo transcripts rather than `$XDG_CONFIG_HOME`.
- Post-action UX lacks a unified Outcome section; README now claims every command emits a one-line Outcome plus structured JSON, but the implementation still relies on ad-hoc lines (e.g., "Save complete; …", snapshot bootstrap summary) and lacks the outcome.v1 schema. Auditor facts are available to drive a canonical epilogue. Outcome component remains a priority (CLI-first with outcome.v1 JSON and stdout epilogue). Canonical thread updated to include acceptance tests and exit-code matrix.
- No built-in agent command: Vizier intentionally lacks a `vizier agent run` flow; operators launch Codex directly and handle branch/PR plumbing outside the CLI.
- AGENTS.md contract/log: Describes the scoped `[agents.default]`/`[agents.<scope>]` configuration (backend, model, reasoning, agent/wire details, and prompt profiles), spells out the precedence order (`CLI flags → [agents.<scope>] → [agents.default] → legacy prompts/keys`), and highlights the single-backend-per-command stance (commands fail fast when the configured backend errors; there is no automatic fallback). It still serves as the short orientation note pointing agents to README, `.vizier/narrative/snapshot.md`, prompts, and the draft→approve→review→merge workflow doc; it is not yet a full decision log.
- Repo-level configs now layer on top of global defaults: when no `--config-file` is provided, Vizier loads `$XDG_CONFIG_HOME`/`~/.config/vizier/config.toml` (or platform equivalent) first, overlays `.vizier/config.toml` (or `.json`) while keeping global defaults for unset keys, logs each source, and only falls back to `VIZIER_CONFIG_FILE` when no config files exist. Docs/examples cover the merged precedence, and tests guard agent/gate/review inheritance.
- `vizier plan` is the read-only way to print the fully resolved configuration (global + repo + CLI overrides) with per-command backend/runtime selection before draft/approve/review/merge; it does not start an Auditor session. Use `--json` for structured output.
- Configuration reference now includes quick-start override scenarios (pin review to Gemini, tighten merge gate retries, disable auto-commit, per-scope prompt swaps) plus a config-vs-CLI override matrix. It now documents command-local machine output (`--format json`, `plan --json`) and the trimmed global surface (`--agent`, `--follow`, verbosity, ANSI/session/config/push/no-commit), while AGENTS/README still carry human-authored shorthand that mentions older flag wording pending manual reconciliation. Automated coverage checks help output (quiet + `--no-ansi`, non-TTY pager suppression) alongside a regression that bundled progress filters attach to any agent label with a sibling `filter.sh`. AGENTS currently points at shorthand root-level doc paths, but the canonical files remain `docs/user/config-reference.md` and `docs/user/prompt-config-matrix.md`.
- Documentation config now only honors `include_snapshot`/`include_narrative_docs` (plus the `include_narrative` alias); legacy todo-style keys were dropped now that prompt context ignores `.vizier/todo_*`, and docs point operators to `.vizier/narrative/threads/` instead.
- Narrative GC not yet implemented; policy and levers defined; to be wired into save path and Auditor Outcome.
- Docs prompt templates still ship under `.vizier/docs/prompting/`, but the standalone `vizier docs prompt` command was removed; the upcoming architecture-doc gate (see `.vizier/narrative/threads/architecture_doc_gate_and_commit_history.md`) will wire those templates back into the CLI.
- Legacy side commands (`vizier snapshot …`, `vizier docs prompt …`, and `vizier clean …`) were culled in favor of a lean surface: bootstrap now lives on `vizier init`/`vizier init --check`, and narrative hygiene now relies on Default-Action Posture plus the planned GC work tracked in this snapshot.
- Agent backend path now flows through the script runner in `vizier-core/src/agent.rs` (prompts in `agent_prompt.rs`): agent/gemini scopes resolve to a shell command derived from `agent.label` (bundled shims under `examples/agents/`) or an explicit `agent.command`, render stderr progress history, and fail fast when misconfigured; the wire backend is gone, and CLI/model/reasoning overrides now error instead of being silently ignored.
- ScriptRunner now treats a progress filter's stdout as the assistant output so the bundled `examples/agents/codex-filter.sh` (jq-required) can translate Codex JSONL thread/turn/item events into readable progress lines (with usage summaries) while returning the final/fallback agent message on stdout instead of dropping it when a filter is present; Gemini now ships with `examples/agents/gemini/filter.sh`, and the default Gemini runtime pins wrapped output plus that filter so JSONL streams render progress while preserving the final reply (unit-tested in config).
- Gemini agent shim now mirrors Codex shim by printing the first prompt line preview to stderr before invoking the backend, keeping the CLI tests and operator previews aligned across backends.
- Prompt context loading now tolerates missing `.vizier/` by returning empty snapshot/narrative data instead of panicking, so prompts (e.g., review) stay stable even when executed from a nested or misaligned working directory; context now comes exclusively from `.vizier/narrative/` (legacy `.vizier/.snapshot` and `todo_*` files are no longer loaded).
- Rust-side Codex/Gemini adapters were removed in favor of the bundled script shims; `GEMINI.md` now serves as a historical note describing the former adapter shapes and the current shim entrypoints.
- `vizier test-display` session logging now records user/assistant messages via the Auditor API rather than the removed provider config, keeping agent-only configuration in sync with session artifacts.
- `vizier test-display` exercises the configured backend for any scope without touching `.vizier` or Git; it streams progress through the normal display stack, supports prompt/timeout/raw-output overrides plus `--scope` selection, and only writes a session log when `--session` is passed.
- Scoped agent settings now back every assistant command: `[agents.default]` and `[agents.ask|save|draft|approve|review|merge]` tables (plus CLI overrides) resolve to `AgentSettings` structs that carry a single backend and runtime per command. `vizier-cli` threads those settings through `run_save/ask/draft/approve/review/merge`, enforces capability checks (approve/review require an agent-capable backend; merge auto-resolve refuses unsupported backends), updates agent prompt builders with per-scope bounds, and surfaces the resolved backend+scope in session logs and the token-usage suffix (for example, `agent=agent scope=approve`). Docs and integration tests cover the schema and precedence, including `[agents.ask]` overriding the default, CLI `--backend wire` and `fallback_backend` entries being rejected with clear errors, and model/reasoning overrides being removed alongside the wire backend.
- Auditor commit plumbing now calls `FileTracker::sync_vizier_changes` before writing `.vizier` commits and returns early when nothing changed so Codex‑edited snapshot/narrative files get staged without disturbing pre‑existing staged code. Conversation commits were removed; session IDs + paths travel with the `.vizier` and code commits instead, while inline ask flows still commit `.vizier` changes immediately (Pending Commit gate still pending).
- Token usage reporting is now event-driven: each Codex/wire turn emits `[usage] token-usage — prompt=X (+Δ) completion=Y (+Δ) total=Z (+Δ) cached_input=C (+Δ) reasoning_output=R (+Δ)` progress lines that honor verbosity/TTY gating. CLI summaries now append `(tokens: total=T (+Δ) input=I (+Δ, +C cached) output=O (+Δ, reasoning R))`, and quiet mode suppresses the extra chatter; when the backend withholds usage data we fall back to a single `unknown` line with no deltas. Session logs mirror the same total/input/output breakdown so downstream tooling sees `Token usage: total=T (+Δ) input=I (+Δ, +C cached) output=O (+Δ, reasoning R)` with matching data in `.vizier/sessions/<id>/session.json`.
- Architecture doc compliance: no docs/architecture index exists and saves succeed without citing a doc, so there is no auditable linkage from code changes to architecture intent.
- `vizier draft` (Codex-only) provisions a `draft/<slug>` branch from the primary branch tip via a temporary worktree, runs Codex to generate `.vizier/implementation-plans/<slug>.md`, commits the plan on that branch, then cleans up the worktree so the operator’s checkout stays untouched while stdout reports the plan path/branch pairing.
- `vizier list` now exposes the pending-plan backlog as its own subcommand: it enumerates every `draft/<slug>` branch that sits ahead of the detected (or `--target`) branch, prints a header with the pending count (and target when set), and renders each entry as a label/value block with Plan/Branch/Summary (sanitizing quotes/newlines in summaries); the empty state emits a single `Outcome: No pending draft branches` block. The legacy `vizier approve --list` flag is hidden/deprecated and emits a warning that points to the new command.
- `vizier run <alias>` now queues repo-defined workflow aliases as first-class scheduler DAGs. It supports optional prompt input (`SPEC`/`--file`/stdin), runtime param overrides via repeated `--set KEY=VALUE`, and plan context overrides (`--name`, `--branch`, `--target`, `--yes`, `--after`). Queueing preserves wrapper parity defaults for commit mode, push posture, approve stop-condition settings, merge gate settings, conflict auto-resolve posture, and squash defaults so composed aliases (for example `develop`) behave like the equivalent draft→approve→merge sequence unless explicitly overridden.
- Repo-local develop composition is now restored and tracked in-tree: `.vizier/workflow/draft.toml`, `.vizier/workflow/approve.toml`, and `.vizier/workflow/merge.toml` define stage templates, `.vizier/develop.toml` imports/links those stages into one DAG, and `.vizier/config.toml` maps `[commands].develop = "file:.vizier/develop.toml"` so fixture-seeded repos surface `/commands/develop/template_selector` in `vizier plan --json` and resolve `vizier run develop` without fallback errors.
- Plan workflow commits keep history focused: each draft/approve/review step lands code edits alongside `.vizier/narrative/snapshot.md` and narrative thread updates in a single commit, while plan docs, `.vizier/tmp/*`, and session logs stay scratch artifacts that are filtered out of staging/merge targets.
- `vizier approve` implements the approved plan on the draft branch in a disposable worktree (agent-backed), auto-commits the branch so reviewers can diff against the target, and now streams the backend’s raw stdout/stderr directly to the CLI’s stderr via passthrough mode (token usage recorded as `unknown` when the backend withholds it). Backend failures now emit an explicit `agent backend …` error on stderr before the command aborts so operators/tests can tell the Codex layer failed instead of silently falling back. `vizier review` extends that workflow with a review checkpoint: it spins another worktree, runs the configured checks (defaults to `cargo check --all --all-targets` + `cargo test --all --all-targets` when `Cargo.toml` exists or the `[review.checks]` commands in config), captures the diff summary, streams the backend’s critique to stdout (session logs capture the transcript), marks the plan document `review-ready`, and optionally re-enters the agent to apply fixes using the in-memory critique (prompted unless `--review-only` or `-y/--yes`). `vizier merge` now removes `.vizier/implementation-plans/<slug>.md`, refreshes `.vizier` state, and by default replays the plan branch onto the target, soft-squashes that range into a single implementation commit, then writes a follow-up merge commit (subject `feat: merge plan <slug>`) that embeds the stored plan; in squash mode that merge commit has a single parent (the implementation commit) so the draft branch stays out of the target ancestry, while `--no-squash` keeps the legacy two-parent merge from `draft/<slug>`. When a plan branch contains merge commits, squash mode now preflights the history and requires either `--squash-mainline <parent index>` (or `[merge] squash_mainline`) to select the mainline or `--no-squash` to keep the original graph; ambiguous octopus merges abort early with guidance. The optional CI/CD gate defined under `[merge.cicd_gate]` or `--cicd-script` runs from the repo root while the implementation commit is staged in squash mode (or immediately after the merge commit in legacy mode); success prints the merge summary (deleting the draft branch unless `--keep-branch` is set), while failure streams the script’s stdout/stderr and aborts before deletion/push so operators can inspect the repo. CLI overrides (`--cicd-script PATH`, `--auto-cicd-fix`, `--no-auto-cicd-fix`, `--cicd-retries N`) merge with config, and agent-backed merges can auto-remediate gate failures by applying scoped fixes (amending the implementation commit in squash mode or writing `Fix CI/CD gate failure…` commits in legacy mode) before rerunning the script. Gate checks also run when resuming via `--complete-conflict`. Approve supports `-y/--yes`, `--target`, and `--branch`; Review adds `--review-only`, `--skip-checks`, `-y/--yes`, `--target`, and `--branch`; Merge now supports `-y/--yes`, `--keep-branch`, `--target`, `--branch`, `--note`, `--auto-resolve-conflicts`, `--complete-conflict`, `--cicd-script`, `--auto-cicd-fix`, `--no-auto-cicd-fix`, `--cicd-retries`, and `--[no-]squash`.
- Approve stop condition: `[approve.stop_condition]` (plus `--stop-condition-script`/`--stop-condition-retries`) runs a repo-local script after each approve attempt; a zero exit stops the loop, non-zero triggers another agent run until the default three extra attempts are spent. Each attempt is audited (status/exit/stdout/stderr), epilogues show the script label and attempt counts, and pushes are deferred until a passing run.
- Shell completions: `vizier completions <bash|zsh|fish|powershell|elvish>` prints a dynamic script that wires the hidden `vizier __complete` path to Clap’s completion engine; once sourced, Vizier offers subcommand/flag completion plus `vizier approve`/`vizier merge` positional tab-completion for pending plan slugs via the shared `PlanSlugInventory` helper (scans `.vizier/implementation-plans/*.md` plus `draft/*` branches, filters merged branches, and returns slug/branch/summary metadata for completions, `vizier list`, and docs). README + docs/workflows now call out the command so operators can install it alongside the draft→approve flow.
- Merge conflicts are now resumable: when libgit2 reports conflicts, Vizier materializes the merge index into the working tree, writes a resume token under `.vizier/tmp/merge-conflicts/<slug>.json`, and exits with guidance. Operators can resolve + rerun `vizier merge <slug> --complete-conflict` to reuse the stored commit metadata once the index is clean, or pass `--auto-resolve-conflicts` to let Codex attempt a scoped auto-resolution before falling back to manual cleanup. The completion flag refuses to run when no sentinel exists, when Git isn’t in merge state, or when the operator isn’t on the recorded target branch, keeping history tidy. Sentinel files are deleted automatically once the merge commits.
- Implementation-plan prompting now lives in `vizier-core/src/lib.rs::IMPLEMENTATION_PLAN_PROMPT`, and `vizier-core/src/agent_prompt.rs::build_implementation_plan_prompt` feeds the agent backend the snapshot, active threads, plan slug/branch metadata, and operator spec so the Markdown plan includes front-matter `{plan, branch, status:draft, created_at, spec_source}` plus “Operator Spec” and “Implementation Plan” sections.
- Implementation-plan, review, and merge-conflict prompts are now routed through the agent prompt store: repositories define `[agents.<scope>.prompts.<kind>]` tables in `.vizier/config.toml` that bind a prompt template (inline text or `path`) plus backend/model/reasoning overrides for each command/surface, while `.vizier/IMPLEMENTATION_PLAN_PROMPT.md`, `.vizier/REVIEW_PROMPT.md`, and `.vizier/MERGE_CONFLICT_PROMPT.md` (and legacy `[prompts.*]` entries) remain as fallbacks when no scoped profile is present. Prompt resolution is scoped per command, and every agent call passes its `CommandScope` into the prompt builders so `vizier ask`, `vizier draft`, `vizier review`, and `vizier merge` share the same snapshot-first discipline while tailoring prompts and backends per workflow.
- Implementation-plan inventory is currently mixed: `.vizier/implementation-plans/` currently contains `refactor.md` and `removing-wire.md`, while local branches include `draft/after`, `draft/approve`, `draft/develop`, and `draft/watch` (plus `build/patch-740958c5f8bf`). In this worktree, `.vizier/implementation-plans/watch.md` is also tracked as deleted, so one-to-one hygiene between plan docs and draft branches remains unenforced and pending-plan surfaces can drift.
- Documentation and review prompt text now reference only the snapshot while still embedding narrative docs via `<narrativeDocs>` when configured, matching the new snapshot-first stance.
- Session logs now capture the active prompt scope/kind/origin, and Auditor exposes the repo-relative prompt path (when applicable) alongside the content hash so downstream tooling can tell whether a run used a scoped `[agents.ask.prompts.base]` profile, a `.vizier/*.md` prompt file, or the baked defaults.
- New VCS helpers (`detect_primary_branch`, `create_branch_from`, `add_worktree_for_branch`, `commit_paths_in_repo`, merge helpers, etc.) manage temporary worktrees under `.vizier/tmp-worktrees/` (now gitignored) so `vizier draft` can stage/commit plan files without touching the operator checkout, and enable clean non‑FF merges for approvals.
- Workspace convenience commands deprecated: `vizier cd`/`vizier clean` now error out because the DAG scheduler owns temp worktrees; any future browse/edit workflow must be reintroduced with scheduler-aware semantics.
- `tests/src/lib.rs` exposes standard `#[test]` cases built on an `IntegrationRepo` fixture that clones `test-repo` + `.vizier` into per-test temp dirs, configures Git identity, and caches the release `vizier` binary via `OnceLock`. To harden CI under parallel test load, each `IntegrationRepo` now holds a poison-tolerant global fixture lock for its lifetime and copies the cached `vizier` binary into its own temp repo before spawning commands, removing shared-binary `ENOENT` flakes that previously cascaded across background/build/jobs/save coverage. Coverage still spans workspace cd/clean flows (create/reuse, targeted/all clean, missing-branch failure), `vizier save` flows (including glossary pairing and deleted narrative file coverage), new `vizier init` flows (fresh/partial/full/check/non-mutating-check/outside-git/permission-failure), approve/merge wiring, conflict auto-resolution, sentinel creation, watch-mode schedule guardrails (`test_jobs_schedule_watch_rejects_without_interactive_tty`, `test_jobs_schedule_watch_rejects_with_no_ansi`, `test_jobs_schedule_watch_rejects_incompatible_format`), and the `vizier review --review-only --skip-checks` scenario (now `test_review_streams_critique`, which asserts that no `.vizier/reviews` files exist and the critique header appears in stdout while the plan is marked `review-ready`), plus CI/CD gate tests: `test_merge_cicd_gate_executes_script` (happy path), `test_merge_cicd_gate_failure_blocks_merge` (non-zero script exits block the merge and preserve the draft branch), and `test_merge_cicd_gate_auto_fix_applies_changes` (mock Codex remediation writes the expected fix file and commits the fix attempt). Additional merge-history coverage enforces the `--squash-mainline` guard on plan branches with merge commits (`test_merge_squash_requires_mainline_for_merge_history`, `test_merge_squash_mainline_replays_merge_history`) and confirms `--no-squash` accepts those histories; build execution coverage now asserts queued phase jobs persist `schedule.after` as an explicit empty array when no after-edges are configured. New run-command coverage (`tests/src/run.rs`) verifies composed `run develop` stage chaining, `[commands]` selector precedence over repo fallback files, repo fallback execution for unmapped aliases, and downstream blocking on stage failure.
- Jobs tail follow ordering coverage now asserts per-stream chronology (`stdout` start before `stdout` next, `stderr` start before `stderr` next) rather than brittle cross-stream interleaving, matching the scheduler log streamer contract while keeping both streams observable in `vizier jobs tail --follow`.
- CI gate script resilience: `cicd.sh` now defaults `CARGO_TARGET_DIR` to `.vizier/tmp/cargo-target` when unset and ensures the directory exists before running `cargo fmt/clippy/test`, so permission-restricted repo `target/` directories no longer block gate runs by default; explicit `CARGO_TARGET_DIR` overrides are still honored.
- CI gate script tests: `tests/src/cicd.rs` validates that `./cicd.sh` uses the `.vizier/tmp/cargo-target` fallback when `CARGO_TARGET_DIR` is unset and preserves caller-provided `CARGO_TARGET_DIR` values.
- Agent stdbuf buffering test resilience: the stdbuf progress-flush test now races progress events against agent completion with a longer timeout, reducing load-related flakes while still asserting progress arrives before completion.
- Background pinned-head mismatch test resilience: `test_scheduler_background_ask_fails_on_pinned_head_mismatch` now uses a longer-running mock ask agent and a longer wait-for-running timeout so the test can reliably mutate `HEAD` before apply/cherry-pick and deterministically assert the pinned-head mismatch failure path under suite load.
- `vizier-core/src/vcs.rs` tests use a `TestRepo` fixture plus repo-aware helpers (`stage_in`, `add_and_commit_in`, `push_current_branch_in`, `unstage_in`) instead of mutating the process CWD, so `cargo test -p vizier-core` runs at default parallelism without `--test-threads=1`.
- Build health: `cargo check --all --all-targets`, `cargo test --all --all-targets`, and the repo CI/CD gate script (`./cicd.sh`) pass; the latest rerun on 2026-02-13 is green after re-adding `.vizier/config.toml` `[commands].develop = "file:.vizier/develop.toml"` (with the repo-local develop template bundle) so `plan --json` and composed `run develop` coverage resolve the same selector path again. The 2026-01-30 merge gate failure that flagged ask/background-related tests remains a non-reproducible flake to monitor.
- CI gate repair: removed stray merge-conflict markers in `install.sh`/`tests/src/lib.rs`, restored job-record test helpers, and cleared `.vizier/jobs` in the integration harness so job list tests run against only their fixtures.
- CI gate repair follow-up: removed leftover merge-conflict markers in `tests/src/lib.rs`, `vizier-cli/src/main.rs`, and `vizier-cli/src/jobs.rs`, and reconciled job-record helpers so queue/worktree metadata can coexist in job listings and cleanup.
- CI gate repair (patch tests): restored missing local helpers in `tests/src/patch.rs` (`run_patch_follow`, job-record loading, scope extraction, and non-patch phase filtering) and fixed a stale `first.stdout` reference to use the active command output, resolving compile-time E0425 failures during `./cicd.sh`.
- CI gate repair (develop selector): restored the tracked repo-default alias mapping in `.vizier/config.toml` (`[commands].develop = "file:.vizier/develop.toml"`) after drift to merge-gate-only config broke `test_plan_json_surfaces_develop_alias_selector`; acceptance signal is green `test_plan_json_surfaces_develop_alias_selector`, green `test_run_develop_composed_workflow_succeeds_with_stage_chain`, and a green `./cicd.sh` rerun on 2026-02-13.
- Install script hygiene: `install.sh` no longer contains merge-conflict detritus, so dry-run staging and install/uninstall tests exercise the intended staged-copy flow.
- CLI linting maintenance: `vizier-cli/src/actions.rs`, `vizier-cli/src/jobs.rs`, `vizier-cli/src/main.rs`, and `vizier-cli/src/plan.rs` were tidied for current Rust idioms and lint guidance (error propagation, iterator usage, temp-file handling); the global-flag parsing helper now uses a collapsed `if let` to satisfy clippy with no intended changes to CLI flags, outcomes, or workflow behavior.
- README.md documents `vizier draft`, `vizier list` (standalone pending-plan backlog), `vizier approve` (implementation on the draft branch), and `vizier merge` (default two-commit squash: implementation commit plus a single-parent `feat: merge plan <slug>` commit that embeds the stored plan, with `--no-squash` retaining the draft branch as a second parent) with accurate flags; copy updated to describe the CI/CD gate (`[merge.cicd_gate]`, `--cicd-script`, `--auto-cicd-fix`, `--no-auto-cicd-fix`, `--cicd-retries`), the `--squash-mainline` requirement when squashing plan histories that include merge commits, and scheduler-backed workflow visibility via `--follow` plus `vizier jobs` surfaces. Dedicated DRAFT.md/APPROVE.md are still absent. [Cross: todo_README_add_approve_command.md]
- docs/user/workflows/draft-approve-merge.md now documents both the explicit `vizier draft → vizier approve → vizier merge` choreography and the repo-local composed alias path (`vizier run <alias>`, including `develop`), while still covering prerequisites (including running `vizier init`/`vizier init --check` first), Git effects, conflict sentinels, walkthrough, FAQ, compliance tie-ins, the CI/CD gate (config, CLI overrides, auto-remediation, failure recovery table), and the `--squash-mainline` requirement when squashing plan histories that carry merge commits.
- docs/user/installation.md now documents `vizier init`/`vizier init --check` as the bootstrap contract (durable markers + required runtime ignore rules) and also notes that `./cicd.sh` defaults to `.vizier/tmp/cargo-target` unless `CARGO_TARGET_DIR` is set, preventing local permission drift in repo `target/` from breaking gate runs.
- `vizier release` now emits a single release-notes section (`### Changes`) and only includes entries whose subject lines match Conventional Commit headers (`type:`, `type(scope):`, `type!:`, `type(scope)!:` with non-empty descriptions). Legacy grouped headings (`Breaking Changes`, `Features`, `Fixes/Performance`, `Other`) were removed from dry-run previews and release commit bodies, while `--max-commits` capping and `+N more` overflow behavior remain unchanged. Tag annotation wording now reports one Conventional-commit release-note total instead of category counts, and release docs/tests were updated to match.
- Global `--no-commit` flag (+ `[workflow] no_commit_default`) lets operators hold `.vizier` and plan-branch edits for manual review across ask/save/draft/approve/review. When active, Vizier skips the auto-commit/push, logs that changes are pending, and preserves the disposable worktree for inspection; `vizier merge` still requires auto-commit because merge commits and CI/CD gates depend on finalized history. README and docs call out the new workflow along with the config lever.
- Multi-agent workflows are ad-hoc: there is no structured runbook that walks operators through “discuss → snapshot sign-off → architecture doc draft → implement → code sign-off → save,” so intent can drift between agents and VCS gates.

Acceptance checkpoints (selected)
- Stdout/stderr contract: Non‑TTY emits no ANSI; stdout carries final results; stderr stays limited to errors/warnings per verbosity. Flags -q/-v/-vv and --no-ansi implemented; spinner removed and progress is always line-based under verbosity control. outcome.v1 JSON not yet implemented; standardize across commands. [Active]
- Mode split: `--mode protocol` produces only structured JSON/NDJSON on stdout (no human prose), no ANSI in any environment, deterministic event ordering, and categorized exit codes. Human mode remains default with readable epilogues plus command-local JSON selectors where supported (`plan --json`, `--format json` on list/jobs surfaces). Closed-stdin never blocks. [Active]
- Pending Commit gate guards conversation changes with confirm_destructive=true and auto_commit=false.
- Conversation commits only touch .vizier; preserve pre-existing staged changes exactly (A/M/D/R).
- Non-interactive CLI requires explicit consent; never opens editor.
- Session JSON logging: Assistant operations persist structured session records under repo-local `.vizier/sessions/<id>/session.json` (transcript, repo state, config snapshot, prompt hash, model info, outcome summary); CLI epilogues and commits surface the session path, with schema validation, richer resume UX, gate-aware checkpoints, and redaction controls treated as follow-up work. [Active]
- Outcome summaries: After each operation, users see a compact summary matching Auditor/VCS facts; assistant final mirrors it. For CLI actions, the Auditor-backed A/M/D/R must be reflected in both human epilogue and outcome.v1 JSON. Deterministic final Outcome emission. [CLI-first]
- Narrative GC on save: During `vizier save`, duplicate/superseded/empty/orphaned narrative entries are deleted or staged for deletion per config; Outcome reports deletions with reasons; dry-run supported; protected items skipped. [Active]
- Architecture doc gate: Saves refuse to finalize without a cited architecture doc; outcomes and commits include the referenced path, and multi-agent runs share the same doc reference. [Planned]

Next moves
1) Stdout/stderr contract + verbosity: complete the contract by standardizing a stable stdout Outcome across commands and wiring an outcome.v1 JSON while keeping the new spinner-free, line-based history disciplined. [Active]
2) Outcome component: implement outcome.v1 schema; include audited A/M/D/R, gate state, and (when applicable) {todo, branch, commit_count, pr_url}. Print to stdout on success; expose structured output through protocol mode and command-local JSON selectors instead of a global JSON toggle. Ensure it fires after every ask/save. [Active]
3) Mode split wiring: Add `--mode protocol` to CLI, thread through to core display/observer; enforce protocol-mode IO rules, exit codes, and metadata {mode:"protocol"}. Ensure closed-stdin safe behavior. [Active]
4) Ask gate parity: Place assistant-initiated edits (ask flows) behind a Pending Commit gate instead of immediate commit; surface via Outcome/JSON. Preserve pre-existing staged work. [Active]
5) Narrative GC wiring: Add product‑level GC behavior into the save path with config/flags; surface detailed Outcome facts and integrate with Pending Commit gate where enabled. [Active]
6) Session logging follow-ups: now that repo-local `.vizier/sessions/<id>/session.json` artifacts ship with each run, add resume/diff tooling, redaction levers, and schema validation so downstream agents can trust the record. [Active]
7) Architecture doc enforcement + history: Add compliance gates that require architecture docs for every code change, store doc references alongside commits, and surface discrepancies via Auditor/Outcome before merge. [New]
8) Agent workflow orchestration: Give operators a first-class workflow that sequences snapshot approval, architecture doc drafting, implementation, code sign-off, and final `vizier save`, with Auditor/Outcome breadcrumbs for each checkpoint. [New]
9) Draft approval plumbing: SHIPPED. `vizier approve` applies the plan on the draft branch; `vizier merge` now defaults to the squash flow (single implementation commit plus a follow-up `feat: merge plan <slug>` commit embedding the stored plan, with the merge commit referencing only the implementation commit so `draft/<slug>` drops out of ancestry). `[merge] squash`/`--no-squash` restores the legacy merge that keeps `draft/<slug>` as a second parent. Plan branches with merge commits must supply `--squash-mainline <parent>` (or `[merge] squash_mainline`) in squash mode or fall back to `--no-squash`, with ambiguous octopus merges aborted early. Follow‑ups: standardize Outcome epilogue/JSON for approve/list/merge, add protocol‑mode parity, surface session paths, and surface squash/gate metadata in Outcome/session logs. [Active]
10) Git hygiene + commit practices: Define and document commit-boundary guidelines and commit message conventions for Vizier-driven workflows (code vs `.vizier` vs narrative), ensure CommitMessageBuilder and CLI flows apply them consistently, and surface them in docs/Outcome so human and agent commits keep history clean and auditable; include plan-doc/branch inventory hygiene so pending-plan views stay trustworthy. [New]
11) Manual smoke coverage: run a lightweight human smoke of core CLI flows (ask/save/draft/list/approve/review/merge plus quiet/no-ansi variants), capture session log references, and record regressions as narrative follow-ups so releases do not rely solely on automated checks. [New; see: .vizier/narrative/threads/manual_smoke_cli.md]
12) Workspace/worktree management: define the scheduler-era replacement for `vizier cd/clean` (attach/detach, inventory surfacing, gate alignment) so operators can browse WIP drafts without touching their base checkout. [Active]
13) Docs path reconciliation: align AGENTS.md/README documentation pointers with the on-disk `docs/user/*` paths (or provide root `docs/*` aliases) so orientation guidance has no dead links. [New; see: .vizier/narrative/threads/configuration_posture_and_defaults.md]
14) Workflow-template follow-through: with compile-time capability contracts and pre-queue validation now in place, migrate the remaining approve/review/merge runtime control-loop execution behind compiled template nodes, keep wrapper parity tests green, and surface template/gate facts in unified Outcome/session schemas. [Active; see: .vizier/narrative/threads/workflow_template_reduction_surface.md]

Cross-links
- Output contract + Mode split ↔ Outcome summaries: the same event stream feeds human epilogues, protocol JSON, and CLI results without ANSI leakage.
- DAP ↔ Outcome ↔ Narrative GC: default-action edits update .vizier, GC keeps the garden tidy, and the Outcome line reports those edits.
- Commit isolation + gates ↔ Architecture doc compliance: pending commits and save gates must cite the architecture doc reference and surface it in outcomes/commits.
- Session logging ↔ Auditor facts: assistant operations persist audited facts to session.json, and the Outcome epilogue points to the artifact for downstream tooling.
- Agent workflows ↔ Commit/Doc gates: the same checkpoints that gate architecture docs and pending commits must be surfaced as workflow steps so multi-agent runs stay aligned and auditable.
- Git hygiene + commit practices ↔ Commit isolation/Architecture-doc/Outcome: commit boundaries and commit messaging conventions carry session IDs, gate status, and doc references so repositories get a consistent, reviewable history for both human and agent commits.
- Workflow-template reduction ↔ Agent workflow orchestration/Config posture: wrapper commands keep stable UX while template refs and policy snapshots become the shared, config-first orchestration contract.
